#pragma once

#include <d3d9.h> // for D3D9

// Undocumented enum used by the user callback specified in IDirect3DShaderValidator9::Begin().
// These enum values map directly to D3D9 error codes (which all begin with the prefix "X5%u", where %u is the error ID) that are thrown by the runtime.
typedef enum _D3DSVERROR_ID
{
	// Format for these all is:
	// ERROR_ID = ERROR_NUMBER, // MESSAGE_CATEGORY: "Message text"
	D3DSVERR_OUTOFMEMORY = 0, // 6: "Out of memory"
	D3DSVERR_PS_INST_RESERVED_BIT_USED = 1, // 2: "Reserved bit(s) set in instruction parameter token!  Aborting validation." // This is the same as error code 305
	D3DSVERR_PS_INST_DCL_TOKENCOUNT = 2, // 2: "dcl instruction should have exactly 2 parameter tokens.  Aborting validation." // This is the same as error code 306
	D3DSVERR_PS_DST_RESERVED_BIT_USED = 3, // 2: "Reserved bit(s) set in destination parameter token!  Aborting validation." // This is the same as error code 307
	D3DSVERR_PS_SRC_RESERVED_BIT_USED = 4, // 2: "Reserved bit(s) set in source %d parameter token!  Aborting validation." // This is the same as error code 308
	D3DSVERR_PS_INST_UNEXPECTED_LEN = 5, // 2: "Unexpected DWORD count for instruction.  Aborting validation." // This is the same as error code 309
	D3DSVERR_PS_INVALID_INSTRUCTION = 6, // 2: "Unrecognized instruction. Aborting pixel shader validation."
	D3DSVERR_PS10_VER_VERTEXSHADER = 7, // 6: "Version Token: 0x%x indicates a vertex shader.  Pixel shader version token must be of the form 0xffff****."
	D3DSVERR_PS10_VER_UNKNOWNSHADER = 8, // 6: "Version Token: 0x%x is invalid. Pixel shader version token must be of the form 0xffff****. Aborting pixel shader validation."
	D3DSVERR_PS10_VER_UNSUPPORTED_VERSION = 9, // 6: "Version Token: Shader version %s is not supported by hardware. "
	D3DSVERR_PS10_VER_VERSION_OUT_OF_BOUNDS = 10, // 6: "Version Token: Shader version %s is not supported. Aborting pixel shader validation."
	D3DSVERR_PS10_INST_NOT_SUPPORTED_IN_VERSION = 11, // 2: "Instruction not supported by %s shader."
	D3DSVERR_PS10_INST_INVALID_NUM_PARAMS = 12, // 2: "Invalid parameter count."
	D3DSVERR_PS10_SRC_TEXM3x3SPEC_SRC1_MUST_BE_CONSTREG = 13, // 2: "Second source parameter for texm3x3spec must be c#."
	D3DSVERR_PS10_SRC_TEX_SRC0_MUST_BE_TEXREG = 14, // 2: "Src reg for tex* instruction must be t# register (%s source param)."
	D3DSVERR_PS10_SRC_INVALID_REGTYPE = 15, // 2: "Invalid reg type (%s source param)."
	D3DSVERR_PS10_SRC_REGNUM_OUT_OF_RANGE = 16, // 2: "Invalid reg num %d (%s source param).  Max allowed for this type is %d."
	D3DSVERR_PS10_SRC_BX2_ONLY_VALID_FOR_TEXM = 17, // 2: "_bx2 is a valid src mod for texM* instructions only (%s source param)."
	D3DSVERR_PS10_SRC_BX2_NOT_ALLOWED_ON_TEXREG2 = 18, // 2: "_bx2 cannot be used on src register for texreg2ar or texreg2gb instructions."
	D3DSVERR_PS10_SRC_BX2_NOT_ALLOWED_ON_TEXBEM = 19, // 2: "_bx2 cannot be used on src register for texbem or texbeml instructions."
	D3DSVERR_PS10_SRC_INVALID_SRCMOD = 20, // 2: "Invalid src mod for tex* instruction (%s source param)."
	D3DSVERR_PS10_SRC_TEX_ILLEGAL_SWIZZLE = 21, // 2: "Source swizzle not allowed for tex* instruction (%s source param)."
	D3DSVERR_PS10_SRC_INVALID_REGTYPE2 = 22, // 2: "Invalid reg type for %s source param."
	D3DSVERR_PS10_SRC_REGNUM_OUT_OF_BOUNDS = 23, // 2: "Invalid reg num: %d for %s source param. Max allowed for this type is %d."
	D3DSVERR_PS10_SRC_CMP_DP4_DST_COLLISION = 24, // 2: "For ps_1_2 or ps_1_3, the cmp or dp4 instructions cannot have a source register the same as the destination register."
	D3DSVERR_PS10_SRC_INVALID_SRCMOD2 = 25, // 2: "Invalid src mod for %s source param."
	D3DSVERR_PS10_SRC_B_ONLY_VALID_FOR_SCALARPIPE = 26, // 2: "Src selector .b (%s source param) is only valid for instructions that occur in the alpha pipe."
	D3DSVERR_PS10_SRC_INVALID_SWIZZLE = 27, // 2: "Invalid src swizzle for %s source param."
	D3DSVERR_PS10_NEG_AFTER_SAT = 28, // 2: "Cannot apply a negation source modifier on data that was last written with the saturate destination modifier. Affected components(*) of %s source param: %s"
	D3DSVERR_PS10_USE_SAT_BEFORE_BIAS = 29, // 1: "When using the bias source modifier on a register, the previous writer should apply the saturate modifier. This would ensure consistent behaviour across different hardware. Affected components(*) of %s source param: %s"
	D3DSVERR_PS10_USE_SAT_BEFORE_COMPLEMENT = 30, // 1: "When using the complement source modifier on a register, the previous writer should apply the saturate destination modifier. This would ensure consistent behaviour across different hardware. Affected components(*) of %s source param: %s"
	D3DSVERR_PS10_TEXREG_READ_AFTER_LOCK = 31, // 2: "Texture register result of texkill%s or texm*pad instructions must not be read. Affected components(*) of %s source param: %s"
	D3DSVERR_PS10_TEXREG_READ_AFTER_TEXBEM = 32, // 2: "Texture register result of texbem or texbeml instruction must not be read by tex* instruction. Affected components(*) of %s source param: %s"
	D3DSVERR_VERTDECL_TESS_DX8_METHOD_INVALID = 33, // 4: "Cannot specify method %s or %s on a DX8 driver. On DX8 drivers supporting RT-Patches, the only generation methods allowed are %s and %s. "
	D3DSVERR_PS10_REG_READ_AFTER_TEXBEM = 34, // 2: "Register data that has been read by a texbem or texbeml instruction cannot be read later, except by another texbem/l."
	D3DSVERR_PS10_DEPENDENT_TEXTURE_READS = 35, // 2: "Multiple dependent texture reads are disallowed (%s source param).  Texture read results can be used as an address for subsequent read, but the results from that read cannot be used as an address in yet another subsequent read."
	D3DSVERR_PS10_SRC_UNINITIALIZED_COMPONENT_READ = 36, // 2: "Read of uninitialized component%s(*) in %s%d: %s"
	D3DSVERR_PS10_DST_INVALID_REGTYPE = 37, // 2: "Invalid reg type for dest param."
	D3DSVERR_PS10_DST_REGNUM_OUT_OF_BOUNDS = 38, // 2: "Invalid dest reg num: %d. Max allowed for this reg type is %d."
	D3DSVERR_PS10_DST_TEXM3x2DEPTH_MAY_NOT_BE_USED_ELSEWHERE = 39, // 2: "Destination of texm3x2depth instruction (t%d) is not available elsewhere in shader."
	D3DSVERR_PS10_DST_TEX_MUST_USE_TEXREG = 40, // 2: "Must use texture register a dest param for tex* instructions."
	D3DSVERR_PS10_DST_TEX_INCOMPLETE_WRITEMASK = 41, // 2: "tex* instructions must write all components."
	D3DSVERR_PS10_DST_TEX_INVALID_INSTMODS = 42, // 2: "Instruction modifiers are not allowed for tex* instructions."
	D3DSVERR_PS10_DST_TEX_INVALID_DSTSHIFT = 43, // 2: "Dest shift not allowed for tex* instructions."
	D3DSVERR_PS10_DST_INVALID_WRITEMOD = 44, // 2: "Invalid dst modifier."
	D3DSVERR_PS10_DST_INVALID_SHIFTMOD = 45, // 2: "Invalid dst shift."
	D3DSVERR_PS10_DST_INVALID_WRIETMASK = 46, // 2: "Dest write mask must be .rgb, .a, or .rgba (all)."
	D3DSVERR_PS10_READPORT_TEMPREG_LIMIT_EXCEEDED = 47, // 2: "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d."
	D3DSVERR_PS10_READPORT_INPUTREG_LIMIT_EXCEEDED = 48, // 2: "%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d."
	D3DSVERR_PS10_READPORT_CONSTREG_LIMIT_EXCDEEDED = 49, // 2: "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d."
	D3DSVERR_PS10_READPORT_TEXREG_LIMIT_EXCEEDED = 50, // 2: "%d different texture registers (t#) read by instruction.  Max. different texture registers readable per instruction is %d."
	D3DSVERR_PS10_READPORT_COISSUE_TEMPREG_LIMIT_EXCEEDED = 51, // 2: "%d different temp registers (r#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d."
	D3DSVERR_PS10_READPORT_COISSUE_TEXREG_LIMIT_EXCEEDED = 52, // 2: "%d different texture registers (t#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d."
	D3DSVERR_PS10_DCL_TEX_ALREADY_DECLARED = 53, // 2: "Tex register t%d already declared."
	D3DSVERR_PS10_DCL_TEX_OUT_OF_ORDER_DECL = 54, // 2: "t# registers must appear in sequence (i.e. t0 before t2 OK, but t1 before t0 not valid)."
	D3DSVERR_PS10_TEX_CONSECUTIVE_ERROR = 55, // 2: "Cannot use tex* instruction after non-tex* instruction."
	D3DSVERR_PS10_TEXM_INCOMPLETE_SEQUENCE = 56, // 2: "Incomplete texm* sequence."
	D3DSVERR_PS10_TEXM_INVALID_SEQUENCE = 57, // 2: "Invalid texm* sequence."
	D3DSVERR_PS10_TEXM_INVALID_REGISTER = 58, // 2: "Invalid texm* register."
	D3DSVERR_PS10_CND_SRC0_INVALID = 59, // 2: "First source for cnd instruction must be 'r0.a'."
	D3DSVERR_PS10_CMP_MAX_EXCEEDED = 60, // 2: "Maximum of 3 cmp instructions allowed."
	D3DSVERR_PS10_LRP_INVALID_SRC_MODIFIER = 61, // 2: "The only valid modifiers for the first source parameter of lrp are: reg (no mod) or 1-reg (complement)."
	D3DSVERR_PS10_LRP_SAT_MODIFIER_WARNING = 62, // 1: "Previous writer to the first source register of lrp instruction should apply the saturate destination modifier.  This ensures consistent behaviour across different hardware. Affected components(*) of first source register: %s"
	D3DSVERR_PS10_DEF_MUST_APPEAR_FIRST = 63, // 2: "Const declaration (def) must appear before other instructions."
	D3DSVERR_PS10_DEF_INVALID_FORMAT = 64, // 2: "Destination for def instruction must be of the form c# (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_PS10_DEF_REGISTER_OUT_OF_BOUNDS = 65, // 2: "Invalid const register num: %d. Max allowed is %d."
	D3DSVERR_PS10_DP3_INVALID_WRITEMASK = 66, // 2: "Dest write mask must be .rgb, or .rgba (all) for dp3."
	D3DSVERR_PS10_DP4_MAX_EXCEEDED = 67, // 2: "Maximum of 4 dp4 instructions allowed."
	D3DSVERR_PS10_COISSUE_FIRST_INSTRUCTION_INVALID = 68, // 2: "First arithmetic instruction cannot have co-issue ('+') set; there is no previous arithmetic instruction to pair with."
	D3DSVERR_PS10_COISSUE_TEX_INVALID = 69, // 2: "Cannot set co-issue ('+') on a texture instruction.  Co-issue only applies to arithmetic instructions."
	D3DSVERR_PS10_COISSUE_CONSECUTIVE_ERROR = 70, // 2: "Cannot set co-issue ('+') on consecutive instructions."
	D3DSVERR_PS10_COISSUE_NOP_PREVIOUS_ERROR = 71, // 2: "(previous instruction) nop instruction cannot be co-issued."
	D3DSVERR_PS10_COISSUE_NOP_ERROR = 72, // 2: "nop instruction cannot be co-issued."
	D3DSVERR_PS10_COISSUE_DP4_PREVIOUS_ERROR = 73, // 2: "(previous instruction) dp4 instruction cannot be co-issued."
	D3DSVERR_PS10_COISSUE_DP4_ERROR = 74, // 2: "dp4 instruction cannot be co-issued."
	D3DSVERR_PS10_COISSUE_DP_CONSECUTIVE_ERROR = 75, // 2: "Co-issued instructions cannot both be dot-product, since each require use of the color/vector pipeline to execute."
	D3DSVERR_PS10_COISSUE_DP_CHANNEL_CONFLICT_PREV = 76, // 2: "(previous instruction) Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components."
	D3DSVERR_PS10_COISSUE_DP_ALPHA_ERROR = 77, // 2: "Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used."
	D3DSVERR_PS10_COISSUE_DP_CHANNEL_CONFLICT = 78, // 2: "Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components."
	D3DSVERR_PS10_COISSUE_DP_ALPHA_ERROR_PREV = 79, // 2: "(previous instruction) Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used by the dot product."
	D3DSVERR_PS10_COISSUE_ALLWRITE_ERROR_PREV = 80, // 2: "(previous instruction) Co-issued instruction cannot write all components - must write either alpha or color."
	D3DSVERR_PS10_COISSUE_ALLWRITE_ERROR = 81, // 2: "Co-issued instruction cannot write all components - must write either alpha or color."
	D3DSVERR_PS10_COISSUE_WRITE_COLLISION = 82, // 2: "Co-issued instructions cannot both write to the same components of a register.  Affected components: %s"
	D3DSVERR_PS10_COISSUE_COLORWRITE_COLLISION = 83, // 2: "Co-issued instructions cannot both write to color components."
	D3DSVERR_PS10_COISSUE_ALPHAWRITE_COLLISION = 84, // 2: "Co-issued instructions cannot both write to alpha component."
	D3DSVERR_PS10_PS10_DEPRECATED_FOR_PS11 = 85, // 6: "ps_1_0 is no longer supported.  It turned out that pixel shader capable hardware will always support at least ps_1_1 (which is not as limited a model as ps_1_0 was). To convert a ps_1_0 shader up to ps_1_1, the only change needed is to make the version number 1_1. "
	D3DSVERR_VS10_VS10_DEPRECATED_FOR_VS11 = 86, // 6: "vs_1_0 is no longer supported.  It turned out that vertex shader capable hardware will always support at least vs_1_1 (which is not as limited a model as vs_1_0 was). To convert a vs_1_0 shader up to vs_1_1, the only change needed is to make the version number 1_1. "
	D3DSVERR_PS10_INSTSLOTS_EXCEEDED_TEX = 87, // 6: "Too many texture addressing instruction slots used: %d. Max. allowed is %d. (Note that some texture addressing instructions may use up more than one instruction slot)"
	D3DSVERR_PS10_INSTSLOTS_EXCEEDED_ALU = 88, // 6: "Too many arithmetic instruction slots used: %d. Max. allowed (counting any co-issued pairs as 1) is %d."
	D3DSVERR_PS10_INSTSLOTS_EXCEEDED_TOTAL = 89, // 6: "Total number of instruction slots used too high: %d. Max. allowed (counting any co-issued pairs as 1) is %d."
	D3DSVERR_PS10_R0_UNINITIALIZED = 90, // 6: "r0 must be written by shader. Uninitialized component%s(*): %s"
	D3DSVERR_PS14_VER_VERTEXSHADER = 91, // 6: "Version Token: 0x%x indicates a vertex shader.  Pixel shader version token must be of the form 0xffff****."
	D3DSVERR_PS14_VER_UNKNOWNSHADER = 92, // 6: "Version Token: 0x%x is invalid. Pixel shader version token must be of the form 0xffff****. Aborting pixel shader validation."
	D3DSVERR_PS14_VER_UNSUPPORTED_VERSION = 93, // 6: "Version Token: Shader version %s is not supported by device. "
	D3DSVERR_PS14_VER_VERSION_OUT_OF_BOUNDS = 94, // 6: "Version Token: Shader version %s is not supported. Aborting pixel shader validation."
	D3DSVERR_PS14_INST_UNSUPPORTED_IN_VERSION = 95, // 2: "Instruction not supported by version %s shader."
	D3DSVERR_PS14_INST_INVALID_NUM_PARAMS = 96, // 2: "Invalid parameter count."
	D3DSVERR_PS14_SRC_CONSTREG_MODIFIERS_NOT_ALLOWED = 97, // 2: "(%s source param) Modifiers are not allowed on constants for ps_1_4."
	D3DSVERR_PS14_SRC_TEXCRD_INVALID_REGTYPE = 98, // 2: "(%s source param) Source register type must be texture coordinate input (t#) for texcrd instruction."
	D3DSVERR_PS14_SRC_TEX_INVALID_REGTYPE = 99, // 2: "(%s source param) Source register type must be temp (r#) or texture coordinate input (t#) for tex* instruction."
	D3DSVERR_PS14_SRC_REGNUM_OUT_OF_RANGE = 100, // 2: "(%s source param) Invalid register number: %d.  Max allowed for this type is %d."
	D3DSVERR_PS14_SRC_TEXLDDZ_INVALID_REGTYPE = 101, // 2: "_dz(=_db) modifier on source param for texld only allowed if source is a temp register (r#)."
	D3DSVERR_PS14_SRC_TEXLDDZ_INVALID_SWIZZLE = 102, // 2: "_dz(=_db) modifier on source param for texld must be paired with source selector .xyz(=.rgb). Note: Using no selector is treated same as .xyz here."
	D3DSVERR_PS14_SRC_TEXCRD_DZ_ILLEGAL = 103, // 2: "_dz(=_db) modifier cannot be used on source parameter for texcrd. It is only available to texld instruction, when source parameter is temp register (r#)."
	D3DSVERR_PS14_SRC_TEXLDDW_INVALID_REGTYPE = 104, // 2: "_dw(=_da) modifier on source param for texld only allowed if source is a texture coordinate register (t#)."
	D3DSVERR_PS14_SRC_DW_INVALID_SWIZZLE = 105, // 2: "_dw(=_da) modifier on source param must be paired with source selector .xyw(=.rga)."
	D3DSVERR_PS14_SRC_TEX_INVALID_SRCMOD = 106, // 2: "(%s source param) Invalid source modifier for tex* instruction."
	D3DSVERR_PS14_SRC_TEXCRD_INVALID_SWIZZLE = 107, // 2: "Source for texcrd requires component selector .xyw(==.rga), or .xyz(==.rgb). Note: Using no selector is treated same as .xyz here."
	D3DSVERR_PS14_SRC_TEXLD_TEXREG_INVALID_SWIZZLE = 108, // 2: "Using a texture coordinate register (t#) as source for texld requires component selector .xyw(=.rga), or .xyz(=.rgb). Note: Using no selector is treated same as .xyz here."
	D3DSVERR_PS14_SRC_TEXLD_TEMPREG_INVALID_SWIZZLE = 109, // 2: "Using a temp register (r#) as source for texld requires component selector .xyz(==.rgb). Note: Using no selector is treated same as .xyz here."
	D3DSVERR_PS14_SRC_TEXLD_INVALID_SWIZZLE = 110, // 2: "(%s source param) Invalid source selector for tex* instruction."
	D3DSVERR_PS14_SRC_TEXREG_DIFFERENT_SWIZZLES = 111, // 2: "Texture coordinate register t%d read more than once in shader with different source selector (swizzle). Multiple reads of identical texture coordinate register throughout shader must all use identical source selector. Note this does not restrict mixing use and non-use of a source modifier (i.e. _dw/_da or _dz/_db, depending what the swizzle allows) on these coordinate register reads."
	D3DSVERR_PS14_SRC_TEXREG_ALU_ILLEGAL_USE = 112, // 2: "%sTexture coordinate registers (t#) are not available to arithmetic instructions."
	D3DSVERR_PS14_SRC_INVALID_REGTYPE = 113, // 2: "(%s source param) Invalid register type."
	D3DSVERR_PS14_SRC_REGNUM_OUT_OF_BOUNDS = 114, // 2: "(%s source param) Invalid register number: %d. Max allowed for this type is %d."
	D3DSVERR_PS14_SRC_INVALID_SRCMOD = 115, // 2: "(%s source param) Invalid source modifier."
	D3DSVERR_PS14_SRC_INVALID_SWIZZLE = 116, // 2: "(%s source param) Invalid source selector."
	D3DSVERR_PS14_DZ_DB_MODIFIER_USE_EXCEEDED = 117, // 2: "_dz(=_db) modifier may only be used at most 2 times in a shader."
	D3DSVERR_PS14_SRC_UNINITIALIZED_COMPONENT_READ_TEXCRDPHASE = 118, // 2: "Read of uninitialized component%s(*) in %s%d: %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. In order to read blue again, write to it first. Also: Note that an unfortunate effect of the phase marker earlier in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including the one noted here, are lost. In order to read alpha from an r# register after the phase marker, write to it first."
	D3DSVERR_PS14_SRC_UNINITIALIZED_COMPONENT_READ_PHASE = 119, // 2: "Read of uninitialized component%s(*) in %s%d: %s. Note that an unfortunate effect of the phase marker earlier in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including the one noted here, are lost. In order to read alpha from an r# register after the phase marker, write to it first."
	D3DSVERR_PS14_SRC_UNINITIALIZED_COMPONENT_READ_TEXCRD = 120, // 2: "Read of uninitialized component%s(*) in %s%d: %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. In order to read blue again, write to it first."
	D3DSVERR_PS14_SRC_UNINITIALIZED_COMPONENT_READ = 121, // 2: "Read of uninitialized component%s(*) in %s%d: %s"
	D3DSVERR_PS14_TEX_DEPENDENT_TEX_REQUIRES_PHASE = 122, // 2: "The current tex* instruction reads from %c%d, which was written earlier by another tex* instruction in the same block of tex* instructions.  Dependent reads are not permitted within a single block of tex* instructions.  To perform a dependent read, separate texture coordinate derivation from the tex* instruction using the coordinates with a 'phase' marker."
	D3DSVERR_PS14_DST_INVALID_REGTYPE = 123, // 2: "Invalid register type for destination param."
	D3DSVERR_PS14_DST_REGNUM_OUT_OF_BOUNDS = 124, // 2: "Invalid destination register number: %d. Max allowed for this register type is %d."
	D3DSVERR_PS14_DST_TEXCRD_INVALID_WRITEMASK_DW = 125, // 2: "texcrd with _dw(=_da) source modifier must use .xy(=.rg) destination writemask."
	D3DSVERR_PS14_DST_TEXCRD_INVALID_WRITEMASK = 126, // 2: "texcrd must use .xyz(=.rgb) destination writemask."
	D3DSVERR_PS14_DST_TEXLD_TEXKILL_TEXDEPTH_INCOMPLETE_WRITE = 127, // 2: "texld/texkill/texdepth instructions must write all components."
	D3DSVERR_PS14_DST_TEX_INVALID_INSTMODS = 128, // 2: "Instruction modifiers not allowed for tex* instructions."
	D3DSVERR_PS14_DST_TEX_INVALID_DSTSHIFT = 129, // 2: "Destination shift not allowed for tex* instructions."
	D3DSVERR_PS14_DST_INVALID_WRITEMOD = 130, // 2: "Invalid instruction modifier."
	D3DSVERR_PS14_DST_INVALID_SHIFTMOD = 131, // 2: "Invalid destination shift."
	D3DSVERR_PS14_READPORT_TEMPREG_LIMIT_EXCEEDED = 132, // 2: "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d."
	D3DSVERR_PS14_READPORT_INPUTREG_LIMIT_EXCEEDED = 133, // 2: "%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d."
	D3DSVERR_PS14_READPORT_CONSTREG_LIMIT_EXCDEEDED = 134, // 2: "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d."
	D3DSVERR_PS14_READPORT_TEXREG_LIMIT_EXCEEDED = 135, // 2: "%d different texture coordinate registers (t#) read by instruction.  Max. different texture registers readable per instruction is %d."
	// 136
	// 137
	// 138
	// 139
	D3DSVERR_PS14_PHASE_TEXTURE_STAGE_REUSE = 140, // 2: "Register r%d (and thus texture stage %d) already used as a destination for a tex* instruction in this block of the shader. Reuse of a texture stage in ps_1_4 may only be accmplished by splitting the tex* ops across a phase marker."
	D3DSVERR_PS14_TEX_AFTER_ALU_IN_PHASE = 141, // 2: "tex* instructions cannot be after arithmetic instructions within one phase of a ps_1_4 shader.  Each phase can have a block of tex* instructions followed by a block of arithmetic instructions. "
	D3DSVERR_PS14_PHASE_MULTIPLE_PHASES_DETECTED = 142, // 2: "Multiple phase markers not permitted.  Aborting shader validation."
	D3DSVERR_PS14_PHASE_TEXLDDZ_USED_BEFORE_PHASE = 143, // 2: "Earlier texld instruction used _dz(=_db) modifier on source param. When a phase marker is present, the _dz modifier is only permitted after the phase marker."
	D3DSVERR_PS14_PHASE_COLORREG_READ_BEFORE_PHASE = 144, // 2: "v# register read by instruction(s) before phase marker.  This is not permitted. When a phase marker is present, v# register reads are only permitted after the phase marker."
	D3DSVERR_PS14_PHASE_TEXKILL_BEFORE_PHASE = 145, // 2: "When a phase marker is present in a shader, texkill is only permitted after the phase marker."
	D3DSVERR_PS14_BEM_MULTIPLE_USE = 146, // 2: "bem may only be used once in a shader."
	D3DSVERR_PS14_BEM_MUST_BE_BEFORE_PHASE = 147, // 2: "bem can only be used before a phase marker (required) later in the shader."
	D3DSVERR_PS14_BEM_INVALID_WRITEMASK = 148, // 2: "Writemask for bem must be '.rg'"
	D3DSVERR_PS14_BEM_INVALID_SRC0_REGTYPE = 149, // 2: "First source parameter for bem must be temp (r#) or constant (c#) register."
	D3DSVERR_PS14_BEM_INVALID_SRC1_REGTYPE = 150, // 2: "Second source parameter for bem must be temp (r#) register."
	D3DSVERR_PS14_TEXDEPTH_MULTIPLE_USES = 151, // 2: "Only one use of texdepth is permitted."
	D3DSVERR_PS14_TEXDEPTH_INVALID_DST_REGNUM = 152, // 2: "Destination for texdepth must be r5."
	D3DSVERR_PS14_TEXDEPTH_R5_USE_AFTER_TEXDEPTH = 153, // 2: "After texdepth instruction, r5 is no longer available in shader."
	D3DSVERR_PS14_TEXDEPTH_BEFORE_PHASE = 154, // 2: "When a phase marker is present in a shader, texdepth is only permitted after the phase marker."
	D3DSVERR_PS14_DEF_MUST_APPEAR_FIRST = 155, // 2: "Const declaration (def) must appear before other instructions."
	D3DSVERR_PS14_DEF_INVALID_FORMAT = 156, // 2: "Destination for def instruction must be of the form c# (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_PS14_DEF_REGISTER_OUT_OF_BOUNDS = 157, // 2: "Invalid const register num: %d. Max allowed is %d."
	D3DSVERR_PS14_COISSUE_TEX_INVALID = 158, // 2: "Cannot set co-issue ('+') on a tex* instruction.  Co-issue only applies to arithmetic instructions."
	D3DSVERR_PS14_COISSUE_PHASE_INVALID = 159, // 2: "Phase marker cannot be co-issued."
	D3DSVERR_PS14_COISSUE_DP4_ERROR = 160, // 2: "dp4 cannot be coissued.
	D3DSVERR_PS14_COISSUE_CONSECUTIVE_ERROR = 161, // 2: "Cannot set co-issue ('+') on consecutive instructions."
	D3DSVERR_PS14_COISSUE_PHASE_PREVIOUS_ERROR = 162, // 2: "(previous instruction) phase marker cannot be co-issued."
	D3DSVERR_PS14_COISSUE_DEF_PREVIOUS_ERROR = 163, // 2: "(previous instruction) def cannot be co-issued."
	D3DSVERR_PS14_COISSUE_NOP_PREVIOUS_ERROR = 164, // 2: "(previous instruction) nop cannot be co-issued."
	D3DSVERR_PS14_COISSUE_DP4_PREVIOUS_ERROR = 165, // 2: "(previous instruction) dp4 cannot be co-issued."
	D3DSVERR_PS14_COISSUE_BEM_PREVIOUS_ERROR = 166, // 2: "(previous instruction) bem cannot be co-issued."
	D3DSVERR_PS14_COISSUE_DP_CONSECUTIVE_ERROR = 167, // 2: "Co-issued instructions cannot both be dp3, since each require use of the color pipe to execute."
	D3DSVERR_PS14_COISSUE_DP_CHANNEL_CONFLICT_PREV = 168, // 2: "(previous instruction) dp3 needs color pipe to execute, so instruction co-issued with it cannot write to color components."
	D3DSVERR_PS14_COISSUE_DP_ALPHA_ERROR = 169, // 2: "dp3 which writes alpha cannot co-issue since it uses up both the alpha and color pipes."
	D3DSVERR_PS14_COISSUE_DP_CHANNEL_CONFLICT = 170, // 2: "(previous instruction) dp3 needs color pipe to execute, so instruction co-issued with it cannot write to color components."
	D3DSVERR_PS14_COISSUE_DP_ALPHA_ERROR_PREV = 171, // 2: "(previous instruction) dp3 which writes alpha cannot co-issue since it uses up both the alpha and color pipes."
	D3DSVERR_PS14_COISSUE_ALLWRITE_ERROR_PREV = 172, // 2: "(previous instruction) Individual instruction in co-issue pair cannot write both alpha and color component(s)."
	D3DSVERR_PS14_COISSUE_ALLWRITE_ERROR = 173, // 2: "Individual instruction in co-issue pair cannot write both alpha and color component(s)."
	D3DSVERR_PS14_COISSUE_WRITE_COLLISION = 174, // 2: "Co-issued instructions cannot both write to the same component(s).  One instruction must write to alpha and the other may write to any combination of red/green/blue.  Destination registers may differ."
	D3DSVERR_PS14_COISSUE_ALPHAWRITE_MISSING = 175, // 2: "One of the instructions in a co-issue pair must write to alpha only (.a writemask)."
	D3DSVERR_PS14_INST_TEX_COUNT_OUT_OF_BOUNDS_BEFORE_PHASE = 176, // 6: "Too many (%d) tex* instruction slots used before phase marker. Max. allowed in a phase is %d."
	D3DSVERR_PS14_INST_COUNT_OUT_OF_BOUNDS = 177, // 65542: "Cannot fit shader into length limits for target shader model (ps_1_4). "
	D3DSVERR_PS14_INST_TEX_COUNT_OUT_OF_BOUNDS_AFTER_PHASE = 178, // 6: "Too many (%d) tex* instruction slots used after phase marker. Max. allowed in a phase is %d."
	D3DSVERR_PS14_INST_ALU_COUNT_OUT_OF_BOUNDS_AFTER_PHASE = 179, // 6: "Too many (%d) arithmetic instruction slots used after phase marker. Max. allowed in a phase (counting any co-issued pairs as 1) is %d."
	D3DSVERR_PS14_INST_TEX_COUNT_OUT_OF_BOUNDS = 180, // 6: "Too many (%d) tex* instruction slots used. Max. allowed is %d. Note that adding a phase marker to the shader would double the number of instructions available."
	D3DSVERR_PS14_INST_ALU_COUNT_OUT_OF_BOUNDS = 181, // 6: "Too many (%d) arithmetic instruction slots used. Max. allowed (counting any co-issued pairs as 1) is %d. Note that adding a phase marker to the shader would double the number of instructions available."
	D3DSVERR_PS14_R0_UNINITIALIZED_TEXCRDPHASE = 182, // 2: "r0 must be written by shader. Uninitialized component%s(*): %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. The blue component of r0 must to be written after the texcrd. Also: Note that an unfortunate effect of the phase marker in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including r0, are lost. So after a phase marker, the alpha component of r0 must be written."
	D3DSVERR_PS14_R0_UNINITIALIZED_PHASE = 183, // 2: "r0 must be written by shader. Uninitialized component%s(*): %s. Note that an unfortunate effect of the phase marker in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including r0, are lost. So after a phase marker, the alpha component of r0 must be written."
	D3DSVERR_PS14_R0_UNINITIALIZED_TEXCRD = 184, // 2: "r0 must be written by shader. Uninitialized component%s(*): %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. The blue component of r0 must to be written after the texcrd."
	D3DSVERR_PS14_R0_UNINITIALIZED = 185, // 2: "r0 must be written by shader. Uninitialized component%s(*): %s"
	D3DSVERR_PS20_VER_VERTEXSHADER = 186, // 6: "Version Token: 0x%x indicates a vertex shader.  Pixel shader version token must be of the form 0xffff****."
	D3DSVERR_PS20_VER_UNKNOWNSHADER = 187, // 6: "Version Token: 0x%x is invalid. Pixel shader version token must be of the form 0xffff****. Aborting pixel shader validation."
	D3DSVERR_PS20_VER_UNSUPPORTED_VERSION = 188, // 6: "Version Token: Shader version %s is not supported by device. "
	D3DSVERR_PS20_VER_VERSION_OUT_OF_BOUNDS = 189, // 6: "Version Token: Shader version %s is not supported. Aborting pixel shader validation."
	D3DSVERR_PS20_INST_UNSUPPORTED_IN_VERSION = 190, // 2: "Instruction not supported by version %s pixel shader."
	D3DSVERR_PS20_INST_INVALID_NUM_PARAMS = 191, // 2: "Invalid parameter count."
	D3DSVERR_PS20_SRC0_TEXLD_INVALID_REGTYPE = 192, // 2: "First source parameter for texld must be temp (r#) or texture coordinate input(t#) register."
	D3DSVERR_PS20_SRC1_TEXLD_INVALID_REGTYPE = 193, // 2: "Second source parameter for texld must be sampler stage (s#)."
	D3DSVERR_PS20_NRM_DST_WRITEMASK_INVALID = 194, // 2: "Dest writemask for NRM must be .xyzw (default) or .xyz (or equivalent rgba notation)"
	D3DSVERR_PS20_SRC_INVALID_PARAMETER = 195, // 2: "%sUnexpected source parameter."
	D3DSVERR_PS20_SRC_REGNUM_OUT_OF_BOUNDS = 196, // 2: "(%s source param) Invalid register number: %d.  Max allowed for this type is %d."
	D3DSVERR_PS20_SRC_INVALID_SRCMOD_TEX = 197, // 2: "(%s source param) Source modifier not allowed for tex* instruction."
	D3DSVERR_PS20_SRC_TEX_ILLEGAL_SWIZZLE = 198, // 2: "(%s source param) Source swizzles not allowed on tex* instruction."
	D3DSVERR_PS20_SRC_INVALID_REGTYPE = 199, // 2: "(%s source param) Invalid source register type for instruction."
	D3DSVERR_PS20_SRC_REGNUM_OUT_OF_RANGE = 200, // 2: "(%s source param) Invalid register number: %d. Max allowed for this type is %d."
	D3DSVERR_PS20_SRC_INVALID_SRCMOD = 201, // 2: "(%s source param) Invalid source modifier."
	D3DSVERR_PS20_SRC_INVALID_SWIZZLE = 202, // 2: "%sInvalid source selector: %s. The only available source swizzles in this shader version are: .rgba/xyzw (same as not specifying swizzle), .r/x, .g/y, .b/z, .a/w, .gbra/yzxw, .brga/zxyw and .abgr/wzyx. "
	D3DSVERR_PS20_SRC_SAMPLERREG_UNDECLARED = 203, // 2: "Sampler register s%d has not been declared."
	D3DSVERR_PS20_SRC_UNINITIALIZED_COMPONENT_READ = 204, // 2: "Read of uninitialized component%s(*) in %s%d: %s"
	D3DSVERR_PS20_SRC_NEWLY_UNINITIALIZED_COMPONENT_READ = 205, // 2: ""Note that the %s component of %s%d was previously initialized, but then became uninitialized by a previous instruction (e.g. SINCOS clobbers components)."
	D3DSVERR_PS20_DST_INVALID_REGTYPE = 206, // 2: "Invalid register type for destination param."
	D3DSVERR_PS20_DST_REGNUM_OUT_OF_BOUNDS = 207, // 2: "Invalid destination register number: %d. Max allowed for this register type is %d."
	D3DSVERR_PS20_DST_TEXKILL_INCOMPLETE_WRITE = 208, // 2: "texkill must write all components."
	D3DSVERR_PS20_SINCOS_DST_INVALID_WRITEMASK = 209, // 2: "Dest writemask for SINCOS must be .xy, .x or .y."
	D3DSVERR_PS20_ILLEGAL_INSTMOD = 210, // 2: "Instruction modifiers other than _sat or _pp not permitted. (_sat is permitted only on arithmetic ops, except frc or SINCOS)"
	D3DSVERR_PS20_READPORT_TEMPREG_LIMIT_EXCEEDED = 211, // 2: "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d."
	D3DSVERR_PS20_READPORT_INPUTREG_TEXREG_LIMIT_EXCEEDED = 212, // 2: "%d different input (v#) or texture (t#) registers read by instruction.  Max. different input/texture registers readable per instruction is %d."
	D3DSVERR_PS20_READPORT_CONSTREG_LIMIT_EXCDEEDED = 213, // 2: "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d.(There is one exception: this rule does not apply to the SINCOS macro instruction.)"
	D3DSVERR_PS30_VER_UNSUPPORTED_VERSION = 214, // 6: "Version Token: Shader version %s is not supported by device. "
	D3DSVERR_PS20_DEF_MUST_APPEAR_FIRST = 215, // 2: "def and dcl instructions must appear before other instructions."
	D3DSVERR_PS20_INST_DCL_TOKENCOUNT = 216, // 2: "dcl instruction is missing a parameter."
	D3DSVERR_PS20_INST_DCL_INVALID_REGTYPE = 217, // 2: "Invalid register type for dcl.  Must be t#, v# or s#."
	D3DSVERR_PS20_INST_DCL_REGNUM_OUT_OF_RANGE = 218, // 2: "Invalid register number: %d. Max allowed for %s# register is %d."
	D3DSVERR_PS20_DCL_REG_ALREADY_DECLARED = 219, // 2: "Register %s%d has already been declared."
	D3DSVERR_PS20_DCL_INVALID_MASK = 220, // 2: "dcl %s# must have one of the following masks: x, xy, xyz or xyzw (alternatively: r, rg, rgb, or rgba)."
	D3DSVERR_PS20_DCL_INVALID_TEXDIM = 221, // 2: "dcl %s# must be one of the following types: dcl_2d, dcl_cube or dcl_volume."
	D3DSVERR_PS30_VER_VERSION_OUT_OF_BOUNDS = 222, // 6: "Version Token: Shader version %s is not supported. Aborting pixel shader validation."
	D3DSVERR_PS20_DEF_INVALID_FORMAT = 223, // 2: "Destination for def instruction must be of the form c# (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_PS10_DEF_REG_ALREADY_DEFINED = 224, // 2: "c%d already def'd in the shader. "
	D3DSVERR_PS20_NRM_SRC_DST_COLLISION = 225, // 2: "Src and dest registers for NRM cannot be the same."
	D3DSVERR_PS20_SINCOS_SRC1_REGTYPE_INVALID = 226, // 2: "Second source paramter for SINCOS must be a constant register."
	D3DSVERR_PS20_SINCOS_SRC2_REGTYPE_INVALID = 227, // 2: "Third source paramter for SINCOS must be a constant register."
	D3DSVERR_PS20_SINCOS_SRC1_SRC2_COLLISION = 228, // 2: "Second and third source parameters for SINCOS cannot be the same constant register."
	D3DSVERR_PS20_SINCOS_SRC0_REPLICATE_SWIZZLE = 229, // 2: "Source selector for first source parameter for SINCOS must be .x, .y, .z or .w."
	D3DSVERR_PS20_SINCOS_SRC1_SRC2_INVALID_SRCMOD = 230, // 2: "Second and third source parameters for SINCOS cannot have a modifier."
	D3DSVERR_PS20_SINCOS_SRC1_SRC2_INVALID_SWIZZLE = 231, // 2: "Second and third source parameters for SINCOS must use default swizzle (no swizzle specified, or .xyzw). "
	D3DSVERR_PS20_COISSUE_NOT_SUPPORTED = 232, // 2: "Co-issue ('+') is not supported in this shader version."
	D3DSVERR_PS20_INSTSLOTS_EXCEEDED_TARGET_TEX = 233, // 65542: "Compiled shader code has has many operations that use the texture unit (%d). Max. allowed by the target (%s) is %d."
	D3DSVERR_PS20_INSTSLOTS_EXCEEDED_ALU = 234, // 6: "Too many (%d) standard (non tex*) instruction slots used. Max. allowed is %d."
	D3DSVERR_BEGIN_INVCALL_OUTOFORDER = 235, // 0: "IDirect3DShaderValidator9::Begin called out of order. ::End must be called first."
	D3DSVERR_INSTRUCTION_INVCALL_OUTOFORDER = 236, // 0: "IDirect3DShaderValidator9::Instruction called out of order. ::Begin must be called first."
	D3DSVERR_INSTRUCTION_INVCALL_CALLAFTEREND = 237, // 0: "IDirect3DShaderValidator9::Instruction called out of order. After end token there should be no more instructions.  Call ::End next."
	D3DSVERR_INSTRUCTION_INVCALL_NOINST = 238, // 0: "IDirect3DShaderValidator9::Instruction called with NULL == pdwInst or 0 == cdw."
	D3DSVERR_INSTRUCTION_BADVERTOKENLEN = 239, // 6: "Bad version token.  DWORD count > 1 given. Expected DWORD count to be 1 for version token."
	D3DSVERR_INSTRUCTION_BADVERTOKENTYPE = 240, // 6: "Bad version token.  It indicates neither a pixel shader nor a vertex shader."
	D3DSVERR_INSTRUCTION_BADENDTOKENLEN = 241, // 6: "Bad end token.  DWORD count > 1 given. Expected DWORD count to be 1 for end token."
	D3DSVERR_END_INVCALL_OUTOFORDER = 242, // 0: "IDirect3DShaderValidator9::End called out of order. Call to ::Begin, followed by calls to ::Instruction must occur first."
	D3DSVERR_END_MISSING_ENDTOKEN = 243, // 0: "Shader missing end token."
	D3DSVERR_PSHADER_BADVERTOKEN = 244, // 6: "Version token 0x%x does not represent a pixel shader."
	D3DSVERR_VSHADER_BADVERTOKEN = 245, // 6: "Version token 0x%x does not represent a vertex shader."
	D3DSVERR_VERTDECL_FVF_POSITION_USAGENUM_OUT_OF_RANGE = 246, // 4: "Declaration can't map to LEGACY fixed function FVF because position cannot have usage index greater than 0. Usage index specified is %d."
	D3DSVERR_VERTDECL_FVF_POSITION_INVALID_TYPE = 247, // 4: "Declaration can't map to fixed function FVF because position must use D3DDECLTYPE_FLOAT3."
	D3DSVERR_VERTDECL_FVF_BLENDWEIGHT_DEVICE_INVALID_TYPE = 248, // 4: "Declaration can't map to LEGACY fixed function FVF because driver does not support blend weight."
	D3DSVERR_VERTDECL_FVF_BLENDWEIGHT_INVALID_TYPE = 249, // 4: "Declaration can't map to fixed function FVF because blendweight must use D3DDECLTYPE_FLOAT1/2/3/4."
	D3DSVERR_VERTDECL_FVF_NORMAL_USAGENUM_OUT_OF_RANGE = 250, // 4: "Declaration can't map to LEGACY fixed function FVF because normal cannot have usage index greater than 0. Usage index specified is %d."
	D3DSVERR_VERTDECL_FVF_NORMAL_INVALID_TYPE = 251, // 4: "Declaration can't map to fixed function FVF because normal must use D3DDECLTYPE_FLOAT3."
	D3DSVERR_VERTDECL_FVF_PSIZE_DEVICE_INVALID = 252, // 4: "Declaration can't map to LEGACY fixed function FVF because device does not support psize. "
	D3DSVERR_VERTDECL_FVF_PSIZE_INVALID_TYPE = 253, // 4: "Declaration can't map to fixed function FVF because pointsize must use type D3DDECLTYPE_FLOAT1. "
	D3DSVERR_VERTDECL_FVF_COLOR_INVALID_TYPE = 254, // 4: "Declaration can't map to fixed function FVF because color0/color1 cannot have type other than D3DDECLTYPE_D3DCOLOR"
	D3DSVERR_VERTDECL_FVF_COLOR1_INVALID_TYPE = 255, // 4: "Declaration can't map to fixed function FVF because specular0/color1 cannot have type other than D3DDECLTYPE_D3DCOLOR"
	D3DSVERR_VERTDECL_FVF_BLENDINDICES_DEVICE_INVALID = 256, // 4: "Declaration can't map to LEGACY fixed function FVF because device does not support blendindices. "
	D3DSVERR_VERTDECL_FVF_BLENDINDICES_INVALID_TYPE = 257, // 4: "Declaration can't map to fixed function FVF because blendindices must use type D3DDECLTYPE_UBYTE4 or D3DDECLTYPE_D3DCOLOR. "
	D3DSVERR_VERTDECL_FVF_TEXCOORD_DEVICE_INVALID_TYPE = 258, // 4: "Declaration can't map to LEGACY fixed function FVF because device requires texcoord to use type D3DDECLTYPE_FLOAT2. "
	D3DSVERR_VERTDECL_FVF_TEXCOORD_INVALID_TYPE = 259, // 4: "Declaration can't map to fixed function FVF because texcoord type must be one of: D3DDECLTYPE_FLOAT1/2/3/4."
	D3DSVERR_VERTDECL_FVF_INVALID_ELEMENT_ORDER = 260, // 4: "Declaration can't map to legacy fixed function FVF because vertex element ordering must follow FVF order. "
	D3DSVERR_VERTDECL_INVALID_METHOD_COMBINATION = 261, // 6: "Declaration cannot combine generation method 'lookup'/'lookuppresampled' with methods other than 'default'."
	D3DSVERR_VERTDECL_METHOD_OVERLAP_CONFLICT = 262, // 6: "Declaration element [%d] specifies generation method '%s', but the stream (%d) and offset (%d) specified do not match up with any element in the declaration that has method 'default'."
	D3DSVERR_VS10_VER_UNSUPPORTED_VERSION = 263, // 6: "Version Token: Shader version %s is not supported by device. "
	D3DSVERR_VERTDECL_METHOD_INVALID_TYPE = 264, // 6: "Declaration element [%d] specifies generation method '%s'. For this method, the input data type must be one of: float3, float4, d3dcolor, ubyte4 or short4. Type provided for this element is: %s"
	D3DSVERR_VERTDECL_METHOD_OVERLAP_DEFAULT = 265, // 6: "Declaration element [%d] specifies generation method '%s'. For this method, the input data type listed must be equal to the type at the 'default' element with the specified source stream (%d) and offset (%d). "
	D3DSVERR_VERTDECL_TOO_MANY_ELEMENTS = 266, // 6: "Declaration has too many vertex elements (%d).  Max allowed, including D3DDECL_END(), is %d. Aborting decl validation."
	D3DSVERR_VERTDECL_STREAMNUM_OUT_OF_RANGE = 267, // 4: "Stream index %d is too high.  Max allowed is %d."
	D3DSVERR_VERTDECL_STREAMNUM_OUT_OF_RANGE_FOR_DEVICE = 268, // 4: "Stream number (%d) too high for device.  Max allowed by the device is %d."
	D3DSVERR_VERTDECL_STREAMNUM_NONCONTIGUOUS = 269, // 4: "Stream %d was defined earlier. Current stream index is %d. All vertex element entries for a given stream index must be contiguous."
	D3DSVERR_PS20_SAT_SETP_INVALID_MODIFIER = 270, // 2: "_sat not permitted with setp instruction."
	D3DSVERR_VERTDECL_INVALID_TYPE = 271, // 4: "Type field contains value that is not a member of D3DDECLTYPE. Value: 0x%x.  Aborting decl validation."
	D3DSVERR_VERTDECL_DX8_INVALID_TYPE = 272, // 4: "Input type: '%s' not supported by pre-DX9 driver."
	D3DSVERR_VERTDECL_INVALID_TYPE_FOR_DEVICE = 273, // 4: "Device does not support %s."
	D3DSVERR_VERTDECL_INVALID_METHOD = 274, // 4: "Method field contains value that is not a member of D3DDECLMETHOD. Value: 0x%x. Aborting decl validation.
	D3DSVERR_VERTDECL_METHOD_INVALID_FOR_DEVICE = 275, // 4: "Generation method: 'lookup' is not supported by the device."
	D3DSVERR_VERTDECL_LOOKUP_LOOKUPPRESAMPLED_COLLISION = 276, // 4: "Generation method: 'lookup' and 'lookuppresampled' can only be used once in a decl.  Occurence #%d encountered."
	D3DSVERR_VERTDECL_LOOKUP_INVALID_TYPE = 277, // 4: "Generation method: 'lookup' must use type D3DDECLTYPE_FLOAT2/3/4."
	D3DSVERR_VERTDECL_SOFTWARE_METHOD_INVALID = 278, // 4: "Decl cannot be used with software vertex processing when generation method other that 'default' is used. "
	D3DSVERR_VERTDECL_METHOD_TYPE_STREAMNUM_OFFSET_SPECIAL_CASE = 279, // 4: "Type, Stream, and Offset fields are not used in combination with generation method D3DDECLMETHOD_UV or D3DDECLMETHOD_LOOKUPPRESAMPLED, so Type is required to be D3DDECLTYPE_UNUSED, and Stream and Offset are required to be 0. This 0 requirement is arbitrary, and there is no relevance/conflict if another vertex element actually occupies Stream 0 and Offset 0 using D3DDECLMETHOD_DEFAULT. Encountered Stream=%d, Offset=%d, Type=%d."
	D3DSVERR_PS20_DCL_MODIFIERS_UNSUPPORTED = 280, // 2: "dcl %s# does not support any modifiers."
	D3DSVERR_VERTDECL_INVALID_USAGE = 281, // 4: "Usage field contains value that is not a member of D3DDECLUSAGE. Value: 0x%x. Aborting decl validation."
	D3DSVERR_VERTDECL_USAGENUM_OUT_OF_RANGE = 282, // 4: "UsageIndex %d is too high.  Max allowed is %d."
	D3DSVERR_VERTDECL_FVF_ELEMENT_UNSUPPORTED = 283, // 4: "Declaration can't map to fixed function FVF because usage+index %s,%d is not supported."
	D3DSVERR_VERTDECL_FVF_UNMAPPABLE_ELEMENTS_ORDER = 284, // 4: "Declaration can't map to fixed function FVF because a usage+index pair (%s,%d) that is not valid for fixed function appears between two vertex elements that have usage+index pairs valid for fixed function. For a vertex declaration to map to fixed function, all individual elements that are valid for fixed function must appear contiguously starting from the first element.  Remaining elements at the end do not have to be valid for fixed function, as long as there are few enough that they can be aliased internally to texcoord(n), texcoord(n+1) etc. up to max. texcoord7 (thereby appearing to conform to an FVF, although the aliased values should not be used). "
	D3DSVERR_VERTDECL_DUPLICATE_ELEMENT = 285, // 4: "Usage+UsageIndex pair: %s%d was already defined by element %d."
	D3DSVERR_VERTDECL_FVF_BLENDWEIGHT_COUNT_OUT_OF_RANGE = 286, // 4: "Declaration can't map to fixed function FVF because there are too many blend weights (%d). Max allowed is %d."
	D3DSVERR_VERTDECL_FVF_TEXCOORD_NONSEQUENTIAL = 287, // 6: "Declaration can't map to fixed function FVF because there are gaps in the texture coordinates. "
	D3DSVERR_VERTDECL_FVF_POSITION0_MISSING = 288, // 6: "Declaration can't map to fixed function FVF because position field is missing. Usage: %s, with usage index 0 is required for fixed function."
	D3DSVERR_VERTDECL_FVF_INVALID_METHOD = 289, // 4: "Declaration can't map to fixed function FVF because a generation method other than D3DDECLMETHOD_DEFAULT is used."
	D3DSVERR_VERTDECL_FVF_INVALID_TYPE = 290, // 4: "Declaration can't map to fixed function FVF because the type for this element is unsupported."
	D3DSVERR_VERTDECL_FVF_INVALID_ELEMENT_PLACEMENT = 291, // 4: "Declaration can't map to fixed function FVF because gaps or overlap between vertex elements are not allowed. Offset encountered is: %d, but expected offset is %d."
	D3DSVERR_VERTDECL_FVF_STREAMNUM_OUT_OF_RANGE_LEGACY = 292, // 4: "Declaration can't map to legacy FVF because a nonzero stream index is used: %d."
	D3DSVERR_VERTDECL_DX8_INVALID_METHOD = 293, // 4: "Cannot convert vertex declaration for dx8 driver because generation method '%s' is specified.  The only generation methods which can be used with a dx8 driver are 'crossuv' and 'uv' (or else 'default', which does not specify any data generation)."
	D3DSVERR_VERTDECL_FVF_INVALID_METHOD_AND_INVALID_ELEMENTS = 294, // 4: "Declaration can't map to fixed function FVF because there are both (a) elements with usage+index pairs that are not valid for fixed function and (b) generation methods other than DEFAULT in the same decl. For a vertex declaration to map to fixed function, all individual elements with usage+index pairs valid for fixed function must appear contiguously starting from the first element.  Remaining elements at the end do not have to be valid for fixed function, as long as there are few enough that they can be aliased internally to texcoord(n), texcoord(n+1) etc. up to max. texcoord7 (thereby appearing to conform to an FVF, although the aliased values should not be used). Additionally, when such aliasing occurs, all elements in the decl are then required to simply use generation method D3DDECLMETHOD_DEFAULT, for mapping to fixed function to work."
	D3DSVERR_VERTDECL_DX8_TOO_MANY_UNMAPPABLE_ELEMENTS = 295, // 6: "Declaration can't map to fixed function on dx8 driver because there are too many usage+index pairs that are not valid for dx8 driver. To clarify: For a vertex declaration to map to fixed function on a dx8 driver, all individual elements with usage+index pairs that are valid for fixed funtion on dx8 must appear contiguously starting from the first element.  Remaining elements at the end do not have to be valid for fixed function, as long as there are few enough that they can be aliased internally to texcoord(n), texcoord(n+1) etc. up to max. texcoord7 (thereby appearing to conform to a dx8 decl, although the aliased values should not be used). "
	D3DSVERR_INVALID_VS_INSTRUCTION = 296, // 2: "Unrecognized instruction. Aborting vertex shader validation."
	D3DSVERR_PS30_DCL_MUST_APPEAR_FIRST = 297, // 2: "def and dcl instructions must appear before other instructions."
	D3DSVERR_PS30_INST_DCL_TOKENCOUNT = 298, // 2: "dcl instruction is missing a parameter."
	D3DSVERR_PS30_INST_DCL_INVALID_REGTYPE = 299, // 2: "Invalid register type for dcl.  Must be input register (v#), sampler (s#), position (vPos) or face (vFace)."
	D3DSVERR_PS30_INST_DCL_REGNUM_OUT_OF_RANGE = 300, // 2: "Invalid register number: %d. Max allowed for %s# register is %d."
	D3DSVERR_PS30_INST_DCL_OVERLAPPING_DECLARED_COMPONENTS = 301, // 2: "Declaration for register %s%d overlaps previous declaration for the following component(s) of the same register (*): %s"
	D3DSVERR_PS30_INST_DCL_UNKNOWN_USAGE = 302, // 2: "Unrecognized usage type in dcl statement."
	D3DSVERR_PS30_INST_DCL_USAGENUM_OUT_OF_RANGE = 303, // 2: "dcl usage index, %d, is too high.  Max allowed is %d."
	D3DSVERR_PS30_INST_DCL_USAGE_DUPLICATE = 304, // 2: "dcl usage+index: %s,%d has already been specified for an input register."
	D3DSVERR_VS_INST_RESERVED_BIT_USED = 305, // 2: "Reserved bit(s) set in instruction parameter token!  Aborting validation." // This is the same as error code 1
	D3DSVERR_VS_INST_DCL_TOKENCOUNT = 306, // 2: "dcl instruction should have exactly 2 parameter tokens.  Aborting validation." // This is the same as error code 2
	D3DSVERR_VS_DST_RESERVED_BIT_USED = 307, // 2: "Reserved bit(s) set in destination parameter token!  Aborting validation." // This is the same as error code 3
	D3DSVERR_VS_SRC_RESERVED_BIT_USED = 308, // 2: "Reserved bit(s) set in parameter %d source token!  Aborting validation." // This is the same as error code 4
	D3DSVERR_VS_INST_UNEXPECTED_LEN = 309, // 2: "Unexpected DWORD count for instruction.  Aborting validation." // This is the same as error code 5
	D3DSVERR_VS10_VER_VERSION_OUT_OF_BOUNDS = 310, // 6: "Version Token: Shader version %s is not supported. Aborting vertex shader validation."
	D3DSVERR_VS10_VER_PIXELSHADER = 311, // 6: "Version token: 0x%x indicates a pixel shader.  Vertex shader version token must be of the form 0xfffe****."
	D3DSVERR_VS10_VER_UNKNOWNSHADER = 312, // 6: "Version Token: 0x%x is invalid. Vertex shader version token must be of the form 0xfffe****. Aborting vertex shader validation."
	D3DSVERR_VS20_VER_UNSUPPORTED_VERSION = 313, // 6: "Version Token: Shader version %s is not supported by device. "
	D3DSVERR_VS10_INST_UNSUPPORTED_IN_VERSION = 314, // 2: "Instruction not supported by version %s shader."
	D3DSVERR_VS10_INST_INVALID_NUM_PARAMS = 315, // 2: "Invalid parameter count."
	D3DSVERR_VS10_SRC_INVALID_REGTYPE = 316, // 2: "Invalid reg type for %s source param."
	D3DSVERR_VS10_SRC_REGNUM_OUT_OF_RANGE = 317, // 2: "Invalid reg num: %d for %s source param. Max allowed for this type is %d."
	D3DSVERR_VS10_SRC_MATRIX_IMPLIED_REGNUM_OUT_OF_RANGE = 318, // 2: "Reg num: %d for %s source param on matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d."
	D3DSVERR_VS10_SRC_REGNUM_OUT_OF_RANGE2 = 319, // 2: "Invalid reg num: %d for %s source param. Max allowed for this type is %d."
	D3DSVERR_VS10_SRC_MATRIX_IMPLIED_REGNUM_OUT_OF_RANGE2 = 320, // 2: "Reg num: %d for %s source param on matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d."
	D3DSVERR_VS10_SRC_NEG_MATRIX_INVALID = 321, // 2: "Cannot negate second source parameter to vector*matrix instructions."
	D3DSVERR_VS10_SRC_INVALID_SRCMOD = 322, // 2: "Invalid src mod for %s source param."
	D3DSVERR_VS10_RELADDR_NOT_ALLOWED_ON_SRC = 323, // 2: "Address mode must be absolute (%s source param)."
	D3DSVERR_VS10_RELADDR_CONSTREG_MUST_USE_A0_X_ONLY = 324, // 2: "Relative addressing of constant register must reference a0.x only."
	D3DSVERR_VERTDECL_TYPE_INVALID_METHOD = 325, // 4: "Type %s can only be used with generation methods %s or %s. Generation method encountered specified is: %s. "
	D3DSVERR_VS10_SRC_UNINITIALIZED_COMPONENT_READ = 326, // 2: "Read of uninitialized component%s(*) in %s%d: %s"
	D3DSVERR_PS30_SRC_MATRIX_ILLEGAL_SWIZZLE = 327, // 2: "Cannot swizzle second source parameter to vector*matrix instructions."
	D3DSVERR_VS10_A0_INVALID_WRITEMASK = 328, // 2: "Format for address register must be a0.x."
	D3DSVERR_VS10_A0_INVALID_INSTRUCTION_ACCESS = 329, // 2: "Only the mov instruction is allowed to write to the address register."
	D3DSVERR_VS10_DST_INVALID_REGTYPE = 330, // 2: "Invalid reg type for dest param."
	D3DSVERR_VS10_DST_REGNUM_OUT_OF_BOUNDS = 331, // 2: "Invalid dest reg num: %d. Max allowed for this reg type is %d."
	D3DSVERR_VS10_DST_DSTMOD_ILLEGAL = 332, // 2: "Dst modifiers not allowed for vertex shaders."
	D3DSVERR_VS10_DST_DSTSHIFT_ILLEGAL = 333, // 2: "Dest shifts not allowed for vertex shaders."
	D3DSVERR_VS10_DST_WRITEMASK_EMPTY = 334, // 2: "Dest write mask cannot be empty."
	D3DSVERR_VS10_DST_M_SRC_REG_COLLISION = 335, // 2: "Dest register cannot be the same as first source register for m*x* instructions."
	D3DSVERR_VS10_DST_M_IMPLIED_SRC_REG_COLLISION = 336, // 2: "Dest register for m*x* instructions cannot be the same as one of the additional registers implied by the second source register."
	D3DSVERR_VS10_DEF_MUST_APPEAR_FIRST = 337, // 2: "def or dcl instructions must appear before other instructions."
	D3DSVERR_VS10_DEF_INVALID_FORMAT = 338, // 2: "Destination for def instruction must be of the form c# (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_VS10_DEF_REGISTER_OUT_OF_BOUNDS = 339, // 2: "Invalid const register num: %d. Max allowed is %d."
	D3DSVERR_VS10_FRC_INVALID_WRITEMASK = 340, // 2: "The only valid write masks for the FRC instruction are .xy and .y."
	D3DSVERR_VS10_RELADDR_ABSOLUTE_CONSTREG_INVALID_COMBINATION = 341, // 2: "Absolute and relative addressing of constant registers cannot be combined in one instruction."
	D3DSVERR_VS10_RELADDR_DIFFERENT_CONSTREG_RELADDR = 342, // 2: "Different relative addressing of constant registers cannot be combined in one instruction."
	D3DSVERR_VS10_RELADDR_ABSOLUTE_CONSTREG_INVALID_COMBINATION2 = 343, // 2: "Absolute and relative addressing of constant registers cannot be combined in one instruction."
	D3DSVERR_VS10_READPORT_TEMPREG_LIMIT_EXCEEDED = 344, // 2: "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d."
	D3DSVERR_VS10_READPORT_INPUTREG_LIMIT_EXCEEDED = 345, // 2: "%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d."
	D3DSVERR_VS10_READPORT_CONSTREG_LIMIT_EXCDEEDED = 346, // 2: "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d."
	D3DSVERR_VS10_READPORT_MATRIX_MULTIPLE_CONSTREG_READ = 347, // 2: "Multiple constant registers cannot be read by a matrix op."
	D3DSVERR_VS10_READPORT_MATRIX_MULTIPLE_INPUTREG_READ = 348, // 2: "Multiple input registers cannot be read by a matrix op."
	D3DSVERR_VS10_INSTSLOTS_EXCEEDED_TOTAL = 349, // 6: "Number of instruction slots used too high: %d. Max. allowed is %d."
	D3DSVERR_VS10_MUST_FULLY_WRITE_OPOS_COMPONENTS = 350, // 6: "Vertex shader must minimally write all four components (xyzw) of oPos output register.  Missing component%s(*): %s"
	D3DSVERR_VS10_MUST_FULLY_WRITE_OPOS = 351, // 6: "Vertex shader must write all four components (xyzw) of oPos output register."
	D3DSVERR_PS20_VER_PS2SW_INVALID = 352, // 6: "Version Token: Pixel shader version ps_2_sw is for software rasterizers only (e.g. the reference device). Aborting shader validation."
	D3DSVERR_VS20_VER_PIXELSHADER = 353, // 6: "Version token: 0x%x indicates a pixel shader.  Vertex shader version token must be of the form 0xfffe****."
	D3DSVERR_VS20_VER_UNKNOWNSHADER = 354, // 6: "Version Token: 0x%x is invalid. Vertex shader version token must be of the form 0xfffe****. Aborting vertex shader validation."
	D3DSVERR_VS20_VER_VERSION_OUT_OF_BOUNDS = 355, // 6: "Version Token: Shader version %s is not supported. Aborting vertex shader validation.
	D3DSVERR_PS20_GRADIENT_EXCEEDS_DEVICE = 356, // 2: "ps_2_x extended instruction not supported by the hardware (gradient instructions not supported)."
	D3DSVERR_PS20_PRED_INST_DISALLOWS_PREDICATION = 357, // 2: "%s instruction cannot be predicated."
	D3DSVERR_PS30_SRC_MISCREG_REGNUM_OUT_OF_RANGE = 358, // 2: "Invalid reg num for MISCTYPE."
	D3DSVERR_PS30_SRC_REGNUM_OUT_OF_BOUNDS = 359, // 2: "Invalid reg num: %d for %s source param. Max allowed for this type is %d."
	D3DSVERR_PS30_SRC_MATRIX_NO_VFACE_VPOS_REGS = 360, // 2: "vFace or vPos registers cannot be used as sources for matrix operations."
	D3DSVERR_VS20_SRC_REGNUM_OUT_OF_RANGE = 361, // 2: "Invalid reg num: %d for %s source param. Max allowed for this type is %d."
	D3DSVERR_VS20_SRC_MATRIX_IMPLIED_REGNUM_OUT_OF_RANGE = 362, // 2: "Reg num: %d for %s source param on matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d."
	D3DSVERR_PS20_SRC_NEG_INST_INVALID = 363, // 2: "Cannot use negate on source parameter(s) to %s instruction."
	D3DSVERR_PS30_SRC_INVALID_SRCMOD = 364, // 2: "Invalid src mod for %s source param."
	D3DSVERR_PS30_RELADDR_INVALID_RELATIVE_REGTYPE = 365, // 2: "Relative addressing only permitted on input (v#) registers (%s source param)."
	D3DSVERR_VS20_READPORT_CONSTREG_LIMIT_EXCDEEDED = 366, // 2: "More than 2 constants (even identical ones) cannot be read by an instruction. (There is one exception: this rule does not apply to the SINCOS instruction.)"
	D3DSVERR_VS10_SRC_MATRIX_ILLEGAL_SWIZZLE = 367, // 2: "Cannot swizzle second source parameter to vector*matrix instructions."
	D3DSVERR_VS20_PRED_UNINITIALIZED_PREDREG_READ = 368, // 2: "Predicate register read, but uninitialized. Note that the predicate register must be written by setp before it is used, and that flow control instructions invalidate the predicate register's contents. Affected components(*): %s"
	D3DSVERR_VS30_VER_UNSUPPORTED_VERSION = 369, // 6: "Version Token: Shader version %s is not supported by device. "
	D3DSVERR_PS30_RELADDR_AL_UNINITIALIZED = 370, // 2: "aL can only be referenced in the following scenarios: (1) inside a loop/endloop block, or (2) in a subroutine for which in all cases some call below in the stack is in a loop/endloop block. "
	D3DSVERR_PS_RELADDR_AL_INVALID_SWIZZLE = 371, // 2: "When aL is used as a relative address, it must not specify any swizzle, as it is a scalar register. Aborting validation." // This is the same as error code 709
	D3DSVERR_VS20_MOVA_INVALID_DEST_REGTYPE = 372, // 2: "mova instruction can only write to the address register."
	D3DSVERR_PS30_PRED_WRITE_WITHOUT_SETP = 373, // 2: "The only instruction allowed to write to the predicate register is setp."
	D3DSVERR_VS20_DST_REGNUM_OUT_OF_BOUNDS = 374, // 2: "Invalid dest reg num: %d. Max allowed for this reg type is %d."
	D3DSVERR_VS20_DST_DSTMOD_ILLEGAL = 375, // 2: "Dst modifiers not allowed for vertex shaders."
	D3DSVERR_VS20_DST_DSTSHIFT_ILLEGAL = 376, // 2: "Dest shifts not allowed for vertex shaders."
	D3DSVERR_VS20_DST_WRITEMASK_EMPTY = 377, // 2: "Dest write mask cannot be empty."
	D3DSVERR_PS20_DEF_MUST_APPEAR_FIRST2 = 378, // 2: "def or dcl instructions must appear before other instructions."
	D3DSVERR_PS20_DEFI_INVALID_FORMAT = 379, // 2: "Destination for defi instruction must be i# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_VS20_DEF_REGISTER_OUT_OF_BOUNDS = 380, // 2: "Invalid const register num: %d. Max allowed is %d."
	D3DSVERR_VS30_VER_VERSION_OUT_OF_BOUNDS = 381, // 6: "Version Token: Shader version %s is not supported. Aborting vertex shader validation. "
	D3DSVERR_VERTDECL_FVF_POSITIONT_INVALID_TYPE = 382, // 4: "Declaration can't map to fixed function FVF because D3DDECLUSAGE_POSITIONT must use D3DDECLTYPE_FLOAT4 data type."
	D3DSVERR_PS14_COISSUE_PREV_INSTRUCTION_INVALID = 383, // 2: "Instruction cannot have co-issue ('+') set without a previous arithmetic instruction to pair with."
	D3DSVERR_VERTDECL_TESS_INVALID_TYPE = 384, // 4: "Decl element type is %s; D3DDECLTYPE of greater enumerated value than D3DDECLTYPE_SHORT4 cannot be used with tesselation."
	D3DSVERR_VERTDECL_FVF_POSITIONT_AND_BLENDWEIGHT_PRESENT = 385, // 6: "Declaration can't map to fixed function FVF because it has blend weights and a vertex element with D3DDECLUSAGE_POSITIONT. "
	D3DSVERR_VERTDECL_LOOKUP_INVALID_USAGE = 386, // 4: "Generation method: 'lookup' must use usage D3DDECLUSAGE_SAMPLE."
	D3DSVERR_VERTDECL_LOOKUPPRESAMPLED_INVALID_USAGE = 387, // 4: "Generation method: 'lookuppresampled' must use usage D3DDECLUSAGE_SAMPLE."
	D3DSVERR_PS30_RELADDR_ABSOLUTE_INPUTREG_INVALID_COMBINATION = 388, // 2: "Absolute and relative addressing of input registers cannot be combined in one instruction."
	D3DSVERR_PS30_RELADDR_DIFFERENT_INPUTREG_RELADDR = 389, // 2: "Different relative addressing of input registers cannot be combined in one instruction."
	D3DSVERR_PS30_RELADDR_ABSOLUTE_INPUTREG_INVALID_COMBINATION2 = 390, // 2: "Absolute and relative addressing of input registers cannot be combined in one instruction."
	D3DSVERR_VS20_READPORT_TEMPREG_LIMIT_EXCEEDED = 391, // 2: "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d."
	D3DSVERR_VS20_READPORT_INPUTREG_LIMIT_EXCEEDED = 392, // 2: "%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d. "
	D3DSVERR_VS20_READPORT_CONSTREG_LIMIT_EXCDEEDED2 = 393, // 2: "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d. (There is one exception: this rule does not apply to the SINCOS instruction.)"
	D3DSVERR_VS20_READPORT_MATRIX_MULTIPLE_CONSTREG_READ = 394, // 2: "Multiple constant registers cannot be read by a matrix op."
	D3DSVERR_VS20_READPORT_MATRIX_MULTIPLE_INPUTREG_READ = 395, // 2: "Multiple input registers cannot be read by a matrix op."
	D3DSVERR_VS30_FLOWCTRL_IFC_NESTING_EXCEEDS_DEVICE = 396, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VERTDECL_SAMPLE_INVALID_METHOD = 397, // 4: "Usage: 'sample' can be used only with methods D3DDECLMETHOD_LOOKUP or D3DDECLMETHOD_LOOKUPPRESAMPLED."
	D3DSVERR_VS20_DST_SCALAR_REQUIRES_REPLICATE_SWIZZLE = 398, // 2: "When writing to scalar output register, %s instruction must use replicate swizzle on source parameter(s), in order to select single component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_PS10_READPORT_COISSUE_INPUTREG_LIMIT_EXCEEDED = 399, // 2: "%d different input registers (v#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d."
	D3DSVERR_PS10_READPORT_COISSUE_CONSTREG_LIMIT_EXCEEDED = 400, // 2: "%d different constant registers (c#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d."
	D3DSVERR_VERTDECL_LOOKUPPRESAMPLED_INVALID_FOR_DEVICE = 401, // 4: "Generation method: 'lookuppresampled' is not supported by the device."
	D3DSVERR_VERTDECL_LOOKUP_LOOKUPPRESAMPLED_COLLISION2 = 402, // 4: "Generation method: 'lookup' and 'lookuppresampled' can only be used once in a decl.  Occurence #%d encountered."
	D3DSVERR_PS20_DCL_EMPTY_WRITEMASK = 403, // 2: "dcl must specify non-empty mask."
	D3DSVERR_VERTDECL_TESSFACTOR0_INVALID_TYPE_OR_USAGENUM = 404, // 4: "Usage D3DDECLUSAGE_TESSFACTOR should be used only with data type D3DDECLTYPE_FLOAT1 and usage index 0."
	D3DSVERR_PS20_OCOLOR_OC0_UNWRITTEN = 405, // 6: "Pixel shader must minimally write to oC0 (with a mov instruction)."
	D3DSVERR_PS20_OCOLOR_REQUIRES_MOV_INST = 406, // 2: "oCn registers may only be written using the mov instruction."
	D3DSVERR_PS20_OCOLOR_ILLEGAL_INSTMOD = 407, // 2: "Source parameter for instruction writing to oCn cannot use a modifier."
	D3DSVERR_PS20_OCOLOR_ILLEGAL_SWIZZLE = 408, // 2: "Source parameter for instruction writing to oCn cannot use swizzles."
	D3DSVERR_PS20_DST_DSTSHIFT_ILLEGAL = 409, // 2: "Instruction shifts not permitted."
	D3DSVERR_PS20_OCOLOR_ILLEGAL_WRITEMASK = 410, // 2: "Write to oCn register must use full writemask (equivalent to not specifying writemask at all)."
	D3DSVERR_PS20_OCOLOR_MULTIPLE_WRITES = 411, // 2: "oC%d already written. (oCn registers can only be written at most once each)"
	D3DSVERR_PS20_ODEPTH_REQUIRES_MOV_INST = 412, // 2: "oDepth may only be written using the mov instruction."
	D3DSVERR_PS20_ODEPTH_ILLEGAL_INSTMOD = 413, // 2: "Source parameter for instruction writing to oDepth cannot use a modifier."
	D3DSVERR_PS20_ODEPTH_REQUIRES_REPLICATE_SWIZZLE = 414, // 2: "Source parameter for instruction writing to oDepth must use a replicate source swizzle. i.e.: .x | .y | .z | .w or .r | .g | .b | .a.  This identifies the scalar component of the source to send to oDepth."
	D3DSVERR_PS20_ODEPTH_ILLEGAL_WRITEMASK = 415, // 2: "Write to oDepth register must not specify any writemask. (Note, this is equivalent to using a full writemask) oDepth is a scalar output, however a specific rgba/xyzw channel does not apply; the writemask is meaningless. "
	D3DSVERR_PS20_ODEPTH_MULTIPLE_WRITES = 416, // 2: "oDepth already written."
	D3DSVERR_VS30_FLOWCTRL_BREAKCMP_NESTING_EXCEEDS_DEVICE = 417, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s) (due to conditional break that counts towards the same limit). "
	D3DSVERR_PS20_CRS_SRC_DST_COLLISION = 418, // 2: "Dest register for CRS cannot be the same as a source register."
	D3DSVERR_PS20_CRS_SRC_SWIZZLE_ILLEGAL = 419, // 2: "Swizzle not permitted on source paramters to CRS."
	D3DSVERR_PS20_CRS_INVALID_WRITE_MASK = 420, // 2: "Write mask for CRS must be one of: .x | .y | .z | .xy | .xz | .yz | .xyz (or rgba equivalent)"
	D3DSVERR_PS20_POW_SRC_DST_COLLISION = 421, // 2: "Dest register for POW cannot be the same as second source register."
	D3DSVERR_PS20_SRC_REQUIRES_REPLICATE_SWIZZLE = 422, // 2: "%s%s requires replicate swizzle for this parameter in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_PS20_SINCOS_SRC_DST_COLLISION = 423, // 2: "Dest register for SINCOS cannot be the same as first source register."
	D3DSVERR_PS20_DCL_ILLEGAL_WRITEMASK = 424, // 2: "dcl %s# must not specify a writemask (equivalent to a full mask). When samplers are used for texture lookup, 4 components are always returned, including defaults for components that may not be present in the texture format set at the sampler. "
	D3DSVERR_PS20_DST_WRITEMASK_EMPTY = 425, // 2: "Writemask cannot be empty."
	D3DSVERR_PS20_TEX_DEPENDENCY_CHAIN_TOO_LONG = 426, // 65538: "Shader uses texture addressing operations in a dependency chain that is too complex for the target shader model (%s) to handle.  "
	D3DSVERR_VS10_OTREG_NO_COMPONENT_GAPS = 427, // 6: "By the end of a vertex shader, any oTn register written must not have gaps in components, starting from x, in order xyzw. To satisfy this, oT%d requires writing of the additional component%s(*): %s "
	// 428
	// 429
	D3DSVERR_VS10_DST_SCALAR_REQUIRES_REPLICATE_SWIZZLE = 430, // 2: "When writing to scalar output register, %s instruction must use replicate swizzle on source parameter(s), in order to select single component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	// 431
	// 432
	// 433
	// 434
	// 435
	D3DSVERR_VS20_DST_SCALAR_INVALID_INSTRUCTION = 436, // 2: "%s instruction cannot write to scalar output registers (oFog, oPts)."
	// 437
	// 438
	// 439
	// 440
	D3DSVERR_VS10_DST_SCALAR_INVALID_INSTRUCTION = 441, // 2: "%s instruction cannot write to scalar output registers (oFog, oPts)."
	// 442
	// 443
	// 444
	// 445
	// 446
	// 447
	// 448
	D3DSVERR_VS20_NRM_SRC_DST_COLLISION = 449, // 2: "Src and dest registers for NRM cannot be the same."
	D3DSVERR_VS20_NRM_DST_WRITEMASK_INVALID = 450, // 2: "Dest writemask for NRM must be .xyzw (default) or .xyz (or equivalent rgba notation)"
	D3DSVERR_VS20_CRS_DST_REGTYPE_INVALID = 451, // 2: "Dest register type for CRS must be temp (r#)."
	D3DSVERR_VS20_CRS_SRC_DST_COLLISION = 452, // 2: "Dest register for CRS cannot be the same as a source register."
	D3DSVERR_VS20_CRS_SRC_SWIZZLE_ILLEGAL = 453, // 2: "Swizzle not permitted on source paramters to CRS."
	D3DSVERR_VS20_CRS_INVALID_WRITE_MASK = 454, // 2: "Write mask for CRS must be one of: .x | .y | .z | .xy | .xz | .yz | .xyz (or rgba equivalent)"
	D3DSVERR_VS20_POW_SRC_DST_COLLISION = 455, // 2: "Dest register for POW cannot be the same as second source register."
	D3DSVERR_VS20_LRP_SRC_DST_COLLISION = 456, // 2: "Dest register for LRP cannot be the same as first or third source register."
	D3DSVERR_VS20_SINCOS_SRC_DST_COLLISION = 457, // 2: "Dest register for SINCOS cannot be the same as first source register."
	D3DSVERR_VS20_SINCOS_SRC1_REGTYPE_INVALID = 458, // 2: "Second source paramter for SINCOS must be a constant register."
	D3DSVERR_VS20_SINCOS_SRC2_REGTYPE_INVALID = 459, // "Third source paramter for SINCOS must be a constant register."
	D3DSVERR_VS20_SINCOS_SRC1_SRC2_COLLISION = 460, // 2: "Second and third source parameters for SINCOS cannot be the same constant register."
	D3DSVERR_VS20_SINCOS_SRC0_REPLICATE_SWIZZLE = 461, // 2: "Source selector for first source parameter for SINCOS must be .x, .y, .z or .w."
	D3DSVERR_VS20_SINCOS_SRC1_SRC2_INVALID_SRCMOD = 462, // 2: "Second and third source parameters for SINCOS cannot have a modifier."
	D3DSVERR_VS20_SINCOS_SRC1_SRC2_INVALID_SWIZZLE = 463, // 2: "Second and third source parameters for SINCOS must use default swizzle (no swizzle specified, or .xyzw). "
	D3DSVERR_VS20_NRM_DST_REGTYPE_INVALID = 464, // 2: "Dest register type for NRM must be temp (r#)."
	D3DSVERR_VS20_POW_DST_REGTYPE_INVALD = 465, // 2: "Dest register type for POW must be temp (r#)."
	D3DSVERR_PS30_SRC_VPOS_REQUIRES_REPLICATE_SWIZZLE = 466, // 2: "%s requires replicate swizzle for source parameter(s) in order to select component. For the vPos register, this can either be .x or .y (z,w are not available). "
	D3DSVERR_VS20_LRP_DST_REGTYPE_INVALID = 467, // 2: "Dest register type for LRP must be temp (r#)."
	D3DSVERR_VERTDECL_LOOKUP_OVERLAP_TYPE_MISMATCH = 468, // 6: "Declaration element [%d] specifies generation method 'lookup', where stream (%d) and offset (%d) match another element with method 'default'. This is fine, however both elements must list the same data type, which they currently do not."
	D3DSVERR_VS20_SINCOS_DST_REGTYPE_INVALID = 469, // 2: "Dest register type for SINCOS must be temp (r#)."
	D3DSVERR_VS20_SGN_SRC1_SRC2_COLLISION = 470, // 2: "Second and third source params for SGN must both be different temp (r#) registers."
	D3DSVERR_VS20_SGN_SRC0_COLLISION = 471, // 2: "First source param for SGN cannot be the same register as the second or third params."
	D3DSVERR_VS20_SGN_SRC1_SRC2_INVALID_SRCMOD_OR_SWIZZLE = 472, // 2: "Second and third source params for SGN cannot use a source selector, and cannot have a modifier. "
	D3DSVERR_PS30_DCL_EMPTY_WRITEMASK = 473, // 2: "dcl can't specify empty writemask."
	D3DSVERR_PS_RELADDR_TOKEN_MISSING = 474, // 2: "Expected relative address token.  Aborting validation." // This is the same as error code 802
	D3DSVERR_VS_RELADDR_MISSING_REPLICATE_SWIZZLE = 475, // 2: "Relative address must specify a single component selector (.x, .y, .z or .w) to indicate relative address component. Aborting validation."
	D3DSVERR_PS_RELADDR_RESERVED_BIT_SET = 476, // 2: "Reserved bit(s) set in relative address token for source parameter %d!  Aborting validation." // This is the same as error code 805
	D3DSVERR_VS10_DST_M_INVALID_WRITEMASK = 477, // 2: "%s instruction must use destination writemask: .%s"
	D3DSVERR_VS20_DST_M_INVALID_WRITEMASK = 478, // 2: "%s instruction must use destination writemask: .%s"
	D3DSVERR_VS20_DST_M_SRC_REG_COLLISION = 479, // 2: "Dest register cannot be the same as first source register for m*x* instructions."
	D3DSVERR_VS20_DST_M_IMPLIED_SRC_REG_COLLISION = 480, // 2: "Dest register for m*x* instructions cannot be the same as one of the additional registers implied by the second source register."
	D3ESVERR_VS10_DST_SCALAR_INVALID_WRITE_MASK = 481, // 2: "Scalar output registers (oFog, oPts) must have full write mask."
	D3DSVERR_VS10_DST_M_SCALAR_DST = 482, // 2: "M*x* matrix instructions cannot write to scalar output registers (oFog, oPts)."
	D3ESVERR_VS20_DST_SCALAR_INVALID_WRITE_MASK = 483, // 2: "Scalar output registers (oFog, oPts) must have full write mask."
	D3DSVERR_VS20_DST_M_SCALAR_DST = 484, // 2: "M*x* matrix instructions cannot write to scalar output registers (oFog, oPts)."
	D3DSVERR_VS10_SRC_REQUIRES_REPLICATE_SWIZZLE = 485, // 2: "%s requires replicate swizzle for the source parameter in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_PS14_INST_ALU_COUNT_OUT_OF_BOUNDS_BEFORE_PHASE = 486, // 6: "Too many (%d) arithmetic instruction slots used before phase marker. Max. allowed in a phase (counting any co-issued pairs as 1) is %d."
	D3DSVERR_INST_DCL_RESERVED_BIT_SET = 487, // 2: "Reserved bit(s) set in dcl info token!  Aborting validation."
	// 488
	D3DSVERR_PS20_FLOWCTRL_LABEL_MUST_FOLLOW_RET = 489, // 2: "'label' is only permitted directly after a 'ret' instruction. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_LABEL_VALUE_OUT_OF_RANGE = 490, // 2: "Subroutine label number, %d, is too large. Maximum label number is %d. Aborting shader validation."
	D3DSVERR_PS20_FLOWCTRL_LABEL_MULTIPLE_DEFINITIONS = 491, // 2: "Subroutine label number: %d already defined earlier. Aborting shader validation."
	D3DSVERR_PS20_FLOWCTRL_BACKWARDS_CALL = 492, // 2: "Cannot call subroutine label defined earlier in shader (label #%d in this case).  Subroutine call must reference label defined later in shader. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_LOOP_NESTING_LIMIT_EXCEEDED = 493, // 2: "Depth of loop nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_UNMATCHED_ENDLOOP = 494, // 2: "'endloop' instruction does not match up to an 'loop'. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_RET_INSIDE_FLOW_CONTROL = 495, // 2: "'ret' instruction not permitted from inside any flow control block. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_LABEL_MUST_FOLLOW_RET = 496, // 2: "'label' is only permitted directly after a 'ret' instruction. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_ENDIF_UNMATCHED = 497, // 2: "'endif' instruction does not match up to an 'if' or 'else'. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_SUB_NESTING_EXCEEDS_DEVICE = 498, // 65538: "Compiled code results in subroutine call nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_PS20_FLOWCTRL_RET_BAD_PLACEMENT = 499, // 2: "A 'ret' instruction must be followed by either (1) the end of the shader or (2) a 'label' instruction. Aborting shader validation."
	D3DSVERR_PS14_INST_COUNT_OUT_OF_BOUNDS_FOR_PS14 = 500, // 65542: "Cannot fit shader into length limits for target shader model (ps_1_4). "
	D3DSVERR_PS14_INST_COUNT_OUT_OF_BOUNDS_FOR_PS14_2 = 501, // 65542: "Cannot fit shader into length limits for target shader model (ps_1_4). "
	D3DSVERR_PS30_VER_VERTEXSHADER = 502, // 6: "Version Token: 0x%x indicates a vertex shader.  Pixel shader version token must be of the form 0xffff****."
	D3DSVERR_PS20_FLOWCTRL_UNDEFINED_LABEL = 503, // 6: "Subroutine with label #%d called, but never defined."
	D3DSVERR_PS20_FLOWCTRL_UNREFERENCED_LABEL = 504, // 6: "Subroutine label #%d never referenced."
	D3DSVERR_PS20_FLOWCTRL_UNCLOSED_SUBROUTINE = 505, // 6: "End of shader reached without 'ret' to terminate subroutine."
	D3DSVERR_PS20_FLOWCTRL_ELSE_UNMATCHED = 506, // 2: "'else' instruction does not match up to an 'if'. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_UNCLOSED_REP = 507, // 6: "End of shader reached and rep construct was not completed with an endrep. "
	D3DSVERR_PS20_SAT_TEX_INVALID_MODIFIER = 508, // 2: "_sat not permitted on tex* instructions."
	D3DSVERR_PS20_SAT_FRC_INVALID_MODIFIER = 509, // 2: "_sat not permitted with frc instruction."
	D3DSVERR_PS20_SAT_SINCOS_INVALID_MODIFIER = 510, // 2: "_sat not permitted with SINCOS instruction."
	D3DSVERR_PS20_ODEPTH_ILLEGAL_SAT = 511, // 2: "Write to oDepth register cannot use _sat instruction modifier."
	D3DSVERR_PS20_OCOLOR_ILLEGAL_SAT = 512, // 2: "Write to oCn register cannot use _sat instruction modifier."
	D3DSVERR_PS20_SRC_NOT_BOOLREG_FOR_DEVICE = 513, // 2: "On current device, %s requires the condition%s parameter to be boolean constant register (b#). "
	D3DSVERR_PS30_SRC0_NOT_AL = 514, // 2: "loop requires first parameter to be loop counter (aL). "
	D3DSVERR_PS20_SRC_NOT_LABELREG = 515, // 2: "%s instruction requires parameter to be label (l#). "
	D3DSVERR_PS20_SRC_MUST_USE_DEFAULT_SWIZZLE_UNLESS_PREDREG = 516, // 2: "Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.).  The exception is (on shader version > ps_2_0) if the condition is the predicate register, p0, in which case a replicate swizzle must be used in order to select a component. i.e. .x | .y | .z | .w (or rgba equivalent) "
	D3DSVERR_PS30_VER_UNKNOWNSHADER = 517, // 6: "Version Token: 0x%x is invalid. Pixel shader version token must be of the form 0xffff****. Aborting pixel shader validation."
	D3DSVERR_PS30_INST_UNSUPPORTED_IN_VERSION = 518, // 2: "Instruction not supported by version %s shader."
	D3DSVERR_PS20_DP2ADD_SRC2_SCALAR_REQUIRES_REPLICATE_SWIZZLE = 519, // 2: "Third source parameter for dp2add must use a replicate swizzle (.r, .g, .b, .a) to select a scalar component."
	D3DSVERR_VS20_STATIC_FLOWCTRL_EXCEEDS_VERSION = 520, // 6: "Too may static flow control instructions (%d) for this shader model.  Maximum allowed is %d. The shader instructions that count as 1 static flow control instruction each are: (1)call, (2)callnz (with static condition), (3)if (static branch), (4)else (paired with static if), (5)loop, (6)rep. "
	D3DSVERR_PS30_INST_INVALID_NUM_PARAMS = 521, // 2: "Invalid parameter count."
	D3DSVERR_PS14_USE_SAT_BEFORE_COMPLEMENT = 522, // 1: "When using the complement source modifier on a register, the previous writer should apply the saturate destination modifier. This would ensure consistent behaviour across different hardware. Affected components(*) of %s source param: %s"
	D3DSVERR_PS20_SRC2_SRC3_TEXLDD_INVALID_REGTYPE = 523, // 2: "Third and fourth parameters to texldd must be temp (r#), texture (t#), input (v#) or constant (c#) register."
	D3DSVERR_PS14_LRP_SAT_MODIFIER_WARNING = 524, // 1: "Previous writer to the first source register of lrp instruction should apply the saturate destination modifier.  This ensures consistent behaviour across different hardware. Affected components(*) of first source register: %s"
	D3DSVERR_PS30_TEXLD_INVALID_SRC0_REGTYPE = 525, // 2: "First source parameter for texld* must be temp (r#), input (v#) or constant (c#) register."
	D3DSVERR_PS30_SRC2_SRC3_TEXLDD_INVALID_REGTYPE = 526, // 2: "Third and fourth parameters to texldd must be temp (r#), input (v#) or constant (c#) register."
	D3DSVERR_VS30_TEXLD_INVALID_SRC0_REGTYPE = 527, // 2: "First source parameter for texldl must be temp (r#), input (v#) or const (c#) register."
	D3DSVERR_PS30_SRC1_TEXLD_INVALID_REGTYPE = 528, // 2: "Second source parameter for texld* must be sampler stage (s#)."
	D3DSVERR_VS30_SRC1_TEXLD_INVALID_REGTYPE = 529, // 2: "Second source parameter for texldl must be sampler stage (s#)."
	D3DSVERR_PS30_NRM_DST_WRITEMASK_INVALID = 530, // 2: "Dest writemask for NRM must be .xyzw (default) or .xyz (or equivalent rgba notation)"
	D3DSVERR_PS30_SRC_INVALID_PARAMETER = 531, // 2: "Unexpected source parameter."
	D3DSVERR_PS30_SRC_REGNUM_OUT_OF_RANGE = 532, // 2: "(%s source param) Invalid register number: %d.  Max allowed for this type is %d."
	D3DSVERR_PS20_RELADDR_INVALID_ADDRESS_REGTYPE = 533, // 2: "Relative address register must be aL register (%s source param)."
	D3DSVERR_PS30_AL_REGNUM_OUT_OF_RANGE = 534, // 2: "Invalid register number, %d, specified for aL register. Max # supported is %d (%s source param)."
	D3DSVERR_VS20_A_REGNUM_OUT_OF_RANGE = 535, // 2: "Invalid register number, %d, specified for a# (address) register. Max # supported is %d (%s source param)."
	D3DSVERR_PS20_DCL_INVALID_MODIFIER = 536, // 2: "dcl %s# only supports the _centroid modifier (optional hint), and/or _pp modifier (partial precision hint). No other modifiers supported."
	D3DSVERR_PS30_DCL_PSIZE0_INVALID = 537, // 2: "dcl usage+index psize0 cannot be used in a pixel shader."
	D3DSVERR_VERTDECL_LOOKUP_INVALID_OVERLAP = 538, // 6: "Declaration element [%d] specifies generation method 'lookup', but stream (%d) and offset (%d) partially overlap with vertex element [%d] (having method 'default'). Elements with generation method 'lookup' must satisfy either of two conditions: (1) stream+offset+type for 'lookup' element does not overlap at all with any other element having method 'default'. In this case, it is required that incoming vertex data at stream+offset+type specified for 'lookup' element contains coordinates for the lookup. After being used the coords will be discarded and replaced by lookup results in the set of data passed to the rest of the vertex pipe.(2) stream+offset exactly matches another element in declaration having method 'default', and the types of both are the same. In this case, coordinates for lookup come from 'default' element, and output vertex data after lookup contains both 'default' data, plus new lookup results. "
	D3DSVERR_PS10_SRC_CONSTREG_MODIFIERS_NOT_ALLOWED = 539, // 2: "(%s source param) Modifiers are not allowed on constants for ps_1_x."
	D3DSVERR_VS_INST_DCL_INVALID_RESERVED_BIT = 540, // 2: "Bit 31 not set in dcl info token!  Aborting validation." // This is the same as error code 541
	D3DSVERR_PS_INST_DCL_INVALID_RESERVED_BIT = 541, // 2: "Bit 31 not set in dcl info token!  Aborting validation." // This is the same as error code 540
	D3DSVERR_PS_INST_LEN_MISMATCH = 542, // 2: "Instruction length specified for instruction (%d) does not match the token count encountered (%d). Aborting validation." // This is the same as error code 543
	D3DSVERR_VS_INST_LEN_MISMATCH = 543, // 2: "Instruction length specified for instruction (%d) does not match the token count encountered (%d). Aborting validation." // This is the same as error code 542
	D3DSVERR_VERTDECL_METHOD_NEEDS_TESS_DRAW_FUNCTION = 544, // 4: "Vertex declaration containing generation method %s cannot be used with Draw*Primitive*(). DrawTriPatch() or DrawRectPatch() must be used."
	D3DSVERR_VS20_SINCOS_DST_INVALID_WRITEMASK = 545, // 2: "Dest mask for SINCOS must be one of: .x | .y | .xy "
	D3DSVERR_PS20_REGISTER_COMPONENTS_UNDECLARED = 546, // 2: "Component%s of register %s%d being read, but not declared. v# and t# registers must be declared using a dcl statement (down to the component level) in %s. Undeclared component%s(*) being read: %s"
	D3DSVERR_VERTDECL_METHOD_NEEDS_TESS_RECT_DRAW_FUNCTION = 547, // 4: "Vertex declaration containing generation methods %s, %s or %s cannot be used with Draw*Primitive*() or DrawTriPatch().  DrawRectPatch() must be used."
	D3DSVERR_VS20_FLOWCTRL_BREAKCMP_NESTING_LIMIT_EXCEEDED = 548, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d, due to break_cmp that counts towards same limit. Aborting shader validation. "
	D3DSVERR_VERTDECL_METHOD_NEEDS_NONTESS_DRAW_FUNCTION = 549, // 4: "Vertex declaration containing generation methods %s or %s cannot be used with DrawTriPatch() or DrawRectPatch().  Draw*Primitive*() must be used."
	D3DSVERR_VERTDECL_FVF_UNSUPPORTED_METHOD = 550, // 4: "Declaration can't map to fixed function FVF because fixed function pipeline does not support generation methods %s or %s. "
	D3DSVERR_VERTDECL_FVF_INVALID_METHOD_FOR_TYPE_USAGE = 551, // 4: "Declaration can't map to fixed function FVF because fixed function requires that generation methods %s, %s or %s can only be used with type %s and usage being one of: %s, %s, %s or %s."
	D3DSVERR_VERTDECL_FVF_INVALID_METHOD_FOR_USAGE = 552, // 4: "Declaration can't map to fixed function FVF because fixed function requires that generation method %s can only be used with usages %s or %s."
	D3DSVERR_VERTDECL_TESS_METHOD_INVALID_FOR_DEVICE = 553, // 4: "Cannot specify method %s when device does not support RT-Patches. "
	D3DSVERR_PS20_DEFI_REGISTER_OUT_OF_BOUNDS = 554, // 2: "Invalid constant integer (i#) register num: %d. Max allowed is %d."
	D3DSVERR_PS20_FLOWCTRL_INTREG_X_NEGATIVE = 555, // 2: "i%d.x (which represents rep iteration count) cannot be negative. i%d.x is currently def'd as %d. "
	D3DSVERR_PS20_FLOWCTRL_INTREG_X_OUT_OF_BOUNDS = 556, // 2: "i%d.x (which represents rep iteration count) cannot be greater than %d. i%d.x is currently def'd as %d. "
	D3DSVERR_VS20_FLOWCTRL_BREAKCMP_NESTING_LIMIT_EXCEEDED2 = 557, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d, due to break_cmp that counts towards same limit. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_INTREG_Y_OUT_OF_BOUNDS = 558, // 2: "i%d.y (which represents loop initial value) must be in the range [0, %d]. i%d.y is currently def'd as %d. "
	D3DSVERR_PS30_SRC_INVALID_SRCMOD_TEX = 559, // 2: "Source modifier not allowed on sampler (s#) parameter to texld* instruction."
	D3DSVERR_PS30_FLOWCTRL_INTREG_Z_OUT_OF_RANGE = 560, // 2: "i%d.z (which represents loop step value) must be in the range [-%d, %d]. i%d.z is currently def'd as %d. "
	D3DSVERR_PS30_SRC_TEXLD_INVALID_MODIFIER = 561, // 2: "(%s source param) Negate or abs modifiers not permitted on source parameters to texld*"
	D3DSVERR_PS20_DEFB_REGISTER_OUT_OF_BOUNDS = 562, // 2: "Invalid constant bool (b#) register num: %d. Max allowed is %d."
	D3DSVERR_PS20_DEFB_INVALID_FORMAT = 563, // 2: "Destination for defb instruction must be b# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_VS30_SRC_INVALID_SRCMOD_TEX = 564, // 2: "(%s source param) Source modifier not allowed on sampler (s#)."
	D3DSVERR_PS20_SRC_MATRIX_IMPLIED_REGNUM_OUT_OF_RANGE = 565, // 2: "(%s source param) Register number: %d on this parameter for a matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d."
	D3DSVERR_PS20_SRC_NEG_MATRIX_INVALID = 566, // 2: "Cannot negate second source parameter to vector*matrix instructions."
	D3DSVERR_PS10_SRC_MATRIX_ILLEGAL_SWIZZLE = 567, // 2: "Cannot swizzle second source parameter to vector*matrix instructions."
	D3DSVERR_PS20_DST_M_INVALID_WRITEMASK = 568, // 2: "%s instruction must use destination writemask: .%s"
	D3DSVERR_PS20_DST_M_SRC_REG_COLLISION = 569, // 2: "Dest register cannot be the same as first source register for m*x* instructions."
	D3DSVERR_PS20_DST_M_IMPLIED_SRC_REG_COLLISION = 570, // 2: "Dest register for m*x* instructions cannot be the same as one of the additional registers implied by the second source register."
	D3DSVERR_PS20_READPORT_MATRIX_MULTIPLE_CONSTREG_READ = 571, // 2: "Multiple constant registers cannot be read by a matrix op."
	D3DSVERR_PS20_READPORT_MATRIX_MULTIPLE_INPUTREG_TEXREG_READ = 572, // 2: "Multiple input/texture registers cannot be read by a matrix op."
	D3DSVERR_PS20_OCOLOR_OCN_WRITE_GAP = 573, // 6: "When a %s shader writes to oCn, it must write to all of oC(n-1) down to oC0 (no gaps)."
	D3DSVERR_VERTDECL_METHOD_INVALID_NONTRIANGLE = 574, // 4: "Decl using method other than '%s' cannot be used with points or lines. Encountered method: '%s'."
	D3DSVERR_VS30_FLOWCTRL_IFC_NESTING_LIMIT_EXCEEDED = 575, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_PS30_SRC_SAMPLERREG_UNDECLARED = 576, // 2: "Sampler register s%d has not been declared."
	D3DSVERR_VS30_SRC_SAMPLERREG_UNDECLARED = 577, // 2: "Sampler register s%d has not been declared."
	D3DSVERR_PS30_DST_INVALID_REGTYPE = 578, // 2: "Invalid register type for destination param."
	D3DSVERR_PS30_DST_REGNUM_OUT_OF_BOUNDS = 579, // 2: "Invalid destination register number: %d. Max allowed for this register type is %d."
	D3DSVERR_PS30_SINCOS_DST_INVALID_WRITEMASK = 580, // 2: "Dest writemask for SINCOS must be .xy, .x or .y."
	D3DSVERR_PS30_CENTROID_INVALID_MODIFIER = 581, // 2: "_centroid flag only permitted on dcl v# statements."
	D3DSVERR_PS30_READPORT_TEMPREG_LIMIT_EXCEEDED = 582, // 2: "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d."
	D3DSVERR_PS30_READPORT_INPUTREG_LIMIT_EXCEEDED = 583, // 2: "%d different input registers (v*#) read by instruction.  Max. different input registers readable per instruction is %d."
	D3DSVERR_PS30_READPORT_CONSTREG_LIMIT_EXCDEEDED = 584, // 2: "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d."
	D3DSVERR_PS30_DCL_INVALID_TEXDIM = 585, // 2: "dcl %s# must be one of the following types: dcl_2d, dcl_cube or dcl_volume."
	D3DSVERR_VS30_DCL_INVALID_TEXDIM = 586, // 2: "dcl %s# must be one of the following types: dcl_2d, dcl_cube or dcl_volume."
	D3DSVERR_PS30_DEF_INVALID_FORMAT = 587, // 2: "Destination for def instruction must be of the form c# (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_PS14_DEF_REG_ALREADY_DEFINED = 588, // 2: "c%d already def'd in the shader. "
	D3DSVERR_PS20_DEF_REGISTER_OUT_OF_BOUNDS = 589, // 2: "Invalid const register num: %d. Max allowed is %d."
	D3DSVERR_PS20_DEF_REG_ALREADY_DEFINED = 590, // 2: "c%d already def'd in the shader. "
	D3DSVERR_PS20_DEFI_REG_ALREADY_DEFINED = 591, // 2: "i%d already def'd in the shader. "
	D3DSVERR_PS20_DEFB_REG_ALREADY_DEFINED = 592, // 2: "b%d already def'd in the shader. "
	D3DSVERR_PS30_DEF_REGISTER_OUT_OF_BOUNDS = 593, // 2: "Invalid const register num: %d. Max allowed is %d."
	D3DSVERR_PS30_DEF_REG_ALREADY_DEFINED = 594, // 2: "c%d already def'd in the shader. "
	D3DSVERR_PS30_DEFI_REG_ALREADY_DEFINED = 595, // 2: "i%d already def'd in the shader. "
	D3DSVERR_PS30_DEFB_REG_ALREADY_DEFINED = 596, // 2: "b%d already def'd in the shader. "
	D3DSVERR_VS10_DEF_REG_ALREADY_DEFINED = 597, // 2: "c%d already def'd in the shader. "
	D3DSVERR_VS20_DEF_REG_ALREADY_DEFINED = 598, // 2: "c%d already def'd in the shader. "
	D3DSVERR_VS20_DEFI_REG_ALREADY_DEFINED = 599, // 2: "i%d already def'd in the shader. "
	D3DSVERR_VS20_DEFB_REG_ALREADY_DEFINED = 600, // 2: "b%d already def'd in the shader. "
	D3DSVERR_VS30_DEF_REG_ALREADY_DEFINED = 601, // 2: "c%d already def'd in the shader. "
	D3DSVERR_VS30_DEFI_REG_ALREADY_DEFINED = 602, // 2: "i%d already def'd in the shader. "
	D3DSVERR_VS20_DEFB_REG_ALREADY_DEFINED2 = 603, // 2: "b%d already def'd in the shader. "
	D3DSVERR_PS30_NRM_SRC_DST_COLLISION = 604, // 2: "Src and dest registers for NRM cannot be the same."
	D3DSVERR_PS30_SINCOS_SRC0_REPLICATE_SWIZZLE = 605, // 2: "Source selector for first source parameter for SINCOS must be .x, .y, .z or .w."
	D3DSVERR_PS30_COISSUE_NOT_SUPPORTED = 606, // 2: "Co-issue ('+') is not supported in this shader version."
	D3DSVERR_PS20_INSTSLOTS_EXCEEDED_TEX = 607, // 6: "Too many (%d) tex* instruction slots used. Max. allowed is %d."
	D3DSVERR_PS20_INSTSLOTS_EXCEEDED_DEVICE_ALU = 608, // 65542: "Compiled shader code uses too many arithmetic instruction slots (%d). Max. allowed by the target (%s) is %d."
	D3DSVERR_PS20_INSTSLOTS_EXCEEDED_TARGET_TOTAL = 609, // 65542: "Compiled shader code uses too many instruction slots (%d). Max. allowed by the target (%s) is %d."
	D3DSVERR_PS30_INSTSLOTS_EXCEEDED_TARGET_TOTAL = 610, // 65542: "Compiled shader code uses too many instruction slots (%d). Max. allowed by the target (%s) is %d."
	D3DSVERR_PS30_INSTSLOTS_EXCEEDED_ALLTARGETS_TOTAL = 611, // 6: "Too many instruction slots (%d) used by shader. Max. allowed is %d."
	D3DSVERR_VS10_INSTSLOTS_EXCEEDED_CURRENT_VERSION = 612, // 65542: "Compiled shader code uses too many instruction slots (%d). Max. allowed by the target (%s) is %d."
	D3DSVERR_VS20_FLOWCTRL_COMPLEXITY_EXCEEDS_DEVICE = 613, // 65542: "Shader has too much flow control complexity for the target (%s). "
	D3DSVERR_PS30_FLOWCTRL_BREAKCMP_NESTING_LIMIT_EXCEEDED = 614, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d, due to break_cmp that counts towards same limit. Aborting shader validation. "
	D3DSVERR_VS20_INSTSLOTS_EXCEEDED_CURRENT_VERSION = 615, // 65542: "Compiled shader code uses too many instruction slots (%d). Max. allowed by the target (%s) is %d."
	D3DSVERR_VS30_INSTSLOTS_EXCEEDED_TARGET_TOTAL2 = 616, // 65542: "Compiled shader code uses too many instructions (%d). Max. allowed by the target (%s), including cap for instruction limit, is %d."
	D3DSVERR_PS20_INSTSLOTS_EXCEEDED_TOTAL = 617, // 6: "Too many (%d) total instruction slots used. Max. allowed is %d."
	D3DSVERR_VERTDECL_FVF_COLOR0_MULTIPLE_DEFINITIONS = 618, // 4: "Declaration can't map to fixed function FVF because diffuse0(==color0) defined multiple times."
	D3DSVERR_VERTDECL_FVF_COLOR1_MULTIPLE_DEFINITIONS = 619, // 4: "Declaration can't map to fixed function FVF because specular0(==color1) defined multiple times."
	D3DSVERR_VERTDECL_DX8_OVERLAPPING_ELEMENTS = 620, // 4: "Cannot convert vertex declaration for dx8 driver because the current element overlaps the previous element. Current offset is %d, but is expected to be at least %d."
	D3DSVERR_VERTDECL_DX8_SKIPPED_BYTES_NOT_ALIGNED = 621, // 4: "Cannot convert vertex declaration for dx8 driver because the number of skipped bytes must be a multiple of DWORD size (4 bytes). The number of skipped bytes to reach the current element is: %d."
	D3DSVERR_VS30_INST_DCL_OUTPUT_REGNUM_OUT_OF_RANGE = 622, // 2: "Too many output registers declared (%d).  When no output register has been declared with the semantic 'psize0', %d o# registers are available.  When an o# register has been declared with the semantic 'psize0' (same as 'psize'), %d registers are available."
	D3DSVERR_VS30_DCL_MUST_APPEAR_FIRST = 623, // 2: "def and dcl instructions must appear before other instructions."
	D3DSVERR_VS_INST_DCL_TOKENCOUNT_MISSING = 624, // 2: "dcl instruction is missing a parameter."
	D3DSVERR_VS30_INST_DCL_TOKENCOUNT = 625, // 2: "dcl instruction is missing a parameter."
	D3DSVERR_VS_INST_DCL_INVALID_REGTYPE = 626, // 2: "Invalid register type for dcl.  Must be input register (v#)."
	D3DSVERR_VS30_INST_DCL_INVALID_REGTYPE = 627, // 2: "Invalid register type for dcl.  Must be input register (v#), output register (o#) or sampler (s#)."
	D3DSVERR_VS_INST_DCL_REGNUM_OUT_OF_RANGE = 628, // 2: "Invalid register number: %d. Max allowed for %s# register is %d."
	D3DSVERR_VS30_INST_DCL_REGNUM_OUT_OF_RANGE = 629, // 2: "Invalid register number: %d. Max allowed for %s# register is %d."
	D3DSVERR_PS30_DCL_REG_ALREADY_DECLARED = 630, // 2: "%s register already declared."
	D3DSVERR_PS30_VPOS_DCL_ZW = 631, // 2: "z or w components of vPos register are not available in this shader version, and cannot be dcl'd."
	D3DSVERR_VS_DCL_REG_ALREADY_DECLARED = 632, // 2: "Register %s%d has already been declared."
	D3DSVERR_VS30_INST_DCL_OVERLAPPING_DECLARED_COMPONENTS = 633, // 2: "Declaration for register %s%d overlaps previous declaration for the following component(s) of the same register (*): %s"
	D3DSVERR_VS_INST_DCL_UNKNOWN_USAGE = 634, // 2: "Unrecognized usage type in dcl statement."
	D3DSVERR_VS30_INST_DCL_UNKNOWN_USAGE = 635, // 2: "Unrecognized usage type in dcl statement."
	D3DSVERR_VS_INST_DCL_USAGENUM_OUT_OF_RANGE = 636, // 2: "dcl usage index, %d, is too high.  Max allowed is %d."
	D3DSVERR_VS_INST_DCL_USAGE_DUPLICATE = 637, // 2: "dcl usage: %s%d has already been specified."
	D3DSVERR_VS30_INST_DCL_USAGE_INPUT_DUPLICATE = 638, // 2: "dcl usage+index: %s,%d has already been specified for an input register."
	D3DSVERR_VS30_INST_DCL_USAGE_OUTPUT_DUPLICATE = 639, // 2: "dcl usage+index: %s,%d has already been specified for an output register."
	D3DSVERR_VS20_SRC_MATRIX_ILLEGAL_SWIZZLE = 640, // 2: "Cannot swizzle second source parameter to vector*matrix instructions."
	D3DSVERR_VS30_SRC_MATRIX_ILLEGAL_SWIZZLE = 641, // 2: "Cannot swizzle second source parameter to vector*matrix instructions."
	D3DSVERR_PS30_VER_PS3SW_INVALID = 642, // 6: "Version Token: Pixel shader version ps_3_sw is for use with software rasterizers only (e.g. the reference device). Aborting shader validation."
	D3DSVERR_VS20_VER_VS2SW_INVALID = 643, // 6: "Version Token: Vertex shader version vs_2_sw is for software use only. Aborting shader validation."
	D3DSVERR_VS30_VER_VS3SW_INVALID = 644, // 6: "Version Token: Vertex shader version vs_3_sw is for software use only. Aborting shader validation."
	D3DSVERR_VS30_VER_PIXELSHADER = 645, // 6: "Version token: 0x%x indicates a pixel shader.  Vertex shader version token must be of the form 0xfffe****."
	D3DSVERR_VS30_VER_UNKNOWNSHADER = 646, // 6: "Version Token: 0x%x is invalid. Vertex shader version token must be of the form 0xfffe****. Aborting vertex shader validation."
	D3DSVERR_PS20_FLOWCTRL_PRED_EXCEEDS_DEVICE = 647, // 2: "ps_2_x extended instruction not supported by the hardware (predication not supported)."
	D3DSVERR_PS20_FLOWCTRL_DYNAMIC_EXCEEDS_DEVICE = 648, // 2: "ps_2_x extended instruction not supported by the hardware (dynamic flow control not supported)."
	D3DSVERR_PS20_FLOWCTRL_PRED_STATIC_EXCEEDS_DEVICE = 649, // 2: "ps_2_x extended instruction not supported by the hardware (neither predication or static flow control supported)."
	D3DSVERR_PS20_FLOWCTRL_STATIC_EXCEEDS_DEVICE = 650, // 2: "ps_2_x extended instruction not supported by the hardware (static flow control not supported)."
	D3DSVERR_PS20_PRED_ILLEGAL = 651, // 2: "ps_2_0 does not support predication."
	D3DSVERR_PS20_PRED_UNSUPPORTED_ON_DEVICE = 652, // 2: "vs_2_x [sic] predication not supported by the hardware."
	D3DSVERR_VS20_FLOWCTRL_EXCEEDS_DEVICE = 653, // 2: "vs_2_x extended instruction not supported by the hardware (dynamic flow control not supported)."
	D3DSVERR_VS20_PRED_EXCEEDS_DEVICE = 654, // 2: "vs_2_x extended instruction not supported by the hardware (predication not supported)."
	D3DSVERR_VS20_INST_UNSUPPORTED_IN_VERSION = 655, // 2: "Instruction not supported by version %s shader."
	D3DSVERR_VS20_PRED_ILLEGAL = 656, // 2: "vs_2_0 does not support predication."
	D3DSVERR_VS20_PRED_UNSUPPORTED_ON_DEVICE = 657, // 2: "vs_2_x predication not supported by the hardware."
	D3DSVERR_VS20_PRED_UNSUPPORTED_ON_DEVICE2 = 658, // 2: "vs_2_x predication not supported by the hardware."
	D3DSVERR_VS20_PRED_UNSUPPORTED_ON_DEVICE3 = 659, // 2: "vs_2_x predication not supported by the hardware."
	D3DSVERR_VS20_PRED_UNSUPPORTED_ON_DEVICE4 = 660, // 2: "vs_2_x predication not supported by the hardware."
	D3DSVERR_VS30_INST_UNSUPPORTED_IN_VERSION = 661, // 2: "Instruction not supported by this vertex shader version."
	D3DSVERR_PS20_PRED_SRC_MUST_BE_P0 = 662, // 2: "Source predicate must be p0 register."
	D3DSVERR_PS20_PRED_P0_INVALID_SWIZZLE = 663, // 2: "Source predicate p0 must use one of the following swizzles: .x | .y | .z | .w | .xyzw (same as swizzle not present)"
	D3DSVERR_PS20_PRED_P0_INVALID_SRCMOD = 664, // 2: "The only modifier allowed for source predicate p0 is the not (!) modifier."
	D3DSVERR_PS30_PRED_INST_DISALLOWS_PREDICATION = 665, // 2: "%s instruction cannot be predicated."
	D3DSVERR_PS30_PRED_SRC_MUST_BE_P0 = 666, // 2: "Source predicate must be p0 register."
	D3DSVERR_PS30_PRED_P0_INVALID_SWIZZLE = 667, // 2: "Source predicate p0 must use one of the following swizzles: .x | .y | .z | .w | .xyzw (same as swizzle not present)"
	D3DSVERR_PS30_PRED_P0_INVALID_SRCMOD = 668, // 2: "The only modifier allowed for source predicate p0 is the not (!) modifier."
	D3DSVERR_VS20_INST_INVALID_NUM_PARAMS = 669, // 2: "Invalid parameter count."
	D3DSVERR_VS20_PRED_INST_DISALLOWS_PREDICATION = 670, // 2: "%s instruction cannot be predicated."
	D3DSVERR_VS20_PRED_SRC_MUST_BE_P0 = 671, // 2: "Source predicate must be p0 register."
	D3DSVERR_VS20_PRED_P0_INVALID_SWIZZLE = 672, // 2: "Source predicate p0 must use one of the following swizzles: .x | .y | .z | .w | .xyzw (same as swizzle not present)"
	D3DSVERR_VS20_PRED_P0_INVALID_SRCMOD = 673, // 2: "The only modifier allowed for source predicate p0 is the not (!) modifier."
	D3DSVERR_VS30_INST_INVALID_NUM_PARAMS = 674, // 2: "Invalid parameter count."
	D3DSVERR_VS30_PRED_INST_DISALLOWS_PREDICATION = 675, // 2: "%s instruction cannot be predicated."
	D3DSVERR_VS30_PRED_SRC_MUST_BE_P0 = 676, // 2: "Source predicate must be p0 register."
	D3DSVERR_VS30_PRED_P0_INVALID_SWIZZLE = 677, // 2: "Source predicate p0 must use one of the following swizzles: .x | .y | .z | .w | .xyzw (same as swizzle not present)"
	D3DSVERR_VS30_PRED_P0_INVALID_SRCMOD = 678, // 2: "The only modifier allowed for source predicate p0 is the not (!) modifier."
	D3DSVERR_PS30_SRC_INVALID_REGTYPE = 679, // 2: "Invalid reg type for %s source param."
	D3DSVERR_VS20_SRC_INVALID_REGTYPE = 680, // 2: "Invalid reg type for %s source param."
	D3DSVERR_VS30_SRC_INVALID_REGTYPE = 681, // 2: "Invalid reg type for %s source param."
	D3DSVERR_VS20_SRC_REGNUM_OUT_OF_BOUNDS = 682, // 2: "Invalid reg num: %d for %s source param. Max allowed for this type is %d."	
	D3DSVERR_VS30_SRC_REGNUM_OUT_OF_BOUNDS = 683, // 2: "Invalid reg num: %d for %s source param. Max allowed for this type is %d."
	D3DSVERR_PS30_SRC_MATRIX_IMPLIED_REGNUM_OUT_OF_RANGE = 684, // 2: "Reg num: %d for %s source param on matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d."
	D3DSVERR_VS20_SRC_MATRIX_IMPLIED_REGNUM_OUT_OF_RANGE2 = 685, // 2: "Reg num: %d for %s source param on matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d."
	D3DSVERR_VS30_SRC_MATRIX_IMPLIED_REGNUM_OUT_OF_RANGE = 686, // 2: "Reg num: %d for %s source param on matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d."
	D3DSVERR_VS30_SRC_REGNUM_OUT_OF_BOUNDS2 = 687, // 2: "Invalid reg num: %d for %s source param. Max allowed for this type is %d."
	D3DSVERR_VS30_SRC_MATRIX_IMPLIED_REGNUM_OUT_OF_RANGE2 = 688, // 2: "Reg num: %d for %s source param on matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d."
	D3DSVERR_PS30_SRC1_NEG_ABS_MATRIX_INVALID = 689, // 2: "Cannot use negate or abs on second source parameter to vector*matrix instructions."
	D3DSVERR_PS30_SRC_NEG_ABS_MATRIX_INVALID = 690, // 2: "Cannot use negate or abs on source parameter(s) to %s instruction."
	D3DSVERR_PS30_SRC_VFACE_INVALID_SWIZZLE = 691, // 2: "vFace register must not specify a swizzle (i.e. default swizzle), as it is an implied scalar."
	D3DSVERR_PS30_SRC_VFACE_INVALID_USE = 692, // 2: "vFace register can only be used as one of the sources to if_(cond), break_(cond), setp_(cond), or the condition in a cmp."
	D3DSVERR_VS20_SRC1_NEG_MATRIX_INVALID = 693, // 2: "Cannot use negate on second source parameter to vector*matrix instructions."
	D3DSVERR_VS20_SRC_NEG_MATRIX_INVALID = 694, // 2: "Cannot use negate on source parameter(s) to %s instruction."
	D3DSVERR_VS30_SRC1_NEG_ABS_MATRIX_INVALID = 695, // 2: "Cannot use negate or abs on second source parameter to vector*matrix instructions."
	D3DSVERR_VS30_SRC_NEG_ABS_MATRIX_INVALID = 696, // 2: "Cannot use negate or abs on source parameter(s) to %s instruction."
	D3DSVERR_VS20_SRC_INVALID_SRCMOD = 697, // 2: "Invalid src mod for %s source param."
	D3DSVERR_VS30_SRC_INVALID_SRCMOD = 698, // 2: "Invalid src mod for %s source param."
	D3DSVERR_VS20_RELADDR_INVALID_RELATIVE_REGTYPE = 699, // 2: "Relative addressing only permitted on constant registers (%s source param)."
	D3DSVERR_VS30_RELADDR_INVALID_RELATIVE_REGTYPE = 700, // 2: "Relative addressing of source register only permitted on input (v#) and constant (c#) registers (%s source param)."
	D3DSVERR_VS30_FLOWCTRL_BREAKCMP_NESTING_LIMIT_EXCEEDED = 701, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d, due to break_cmp that counts towards same limit. Aborting shader validation. "
	D3DSVERR_VS20_SRC_INPUTREG_UNDECLARED = 702, // 2: "Input register v%d was not declared with a dcl statement.  Attempt to read component%s(*): %s"
	D3DSVERR_VS30_REGISTER_COMPONENTS_UNDECLARED = 703, // 2: "Attempt to read undeclared component%s of input register v%d (*): %s. Components of v# registers to be read must be declared by a dcl statement."
	D3DSVERR_VS30_REGISTER_COMPONENTS_WRITE_UNDECLARED = 704, // 2: "Attempt to write undeclared component%s of output register o%d (*): %s. Components of o# registers to be written must be declared by a dcl statement."
	D3DSVERR_VS20_RELADDR_AL_UNINITIALIZED = 705, // 2: "aL can only be referenced in the following scenarios: (1) inside a loop/endloop block, or (2) in a subroutine for which in all cases some call below in the stack is in a loop/endloop block. "
	D3DSVERR_VS30_RELADDR_AL_UNINITIALIZED = 706, // 2: "aL can only be referenced in the following scenarios: (1) inside a loop/endloop block, or (2) in a subroutine for which in all cases some call below in the stack is in a loop/endloop block. "
	D3DSVERR_VS30_RELADDR_AL_UNINITIALIZED2 = 707, // 2: "aL can only be referenced in the following scenarios: (1) inside a loop/endloop block, or (2) in a subroutine for which in all cases some call below in the stack is in a loop/endloop block. "
	D3DSVERR_VS30_RELADDR_AL_UNINITIALIZED3 = 708, // 2: "aL can only be referenced in the following scenarios: (1) inside a loop/endloop block, or (2) in a subroutine for which in all cases some call below in the stack is in a loop/endloop block. "
	D3DSVERR_VS_RELADDR_AL_INVALID_SWIZZLE = 709, // 2: "When aL is used as a relative address, it must not specify any swizzle, as it is a scalar register. Aborting validation." // This is the same as error code 371
	D3DSVERR_VS_RELADDR_AL_INVALID_SWIZZLE2 = 710, // 2: "When aL is used as a relative address, it must not specify any swizzle, as it is a scalar register. Aborting validation."
	D3DSVERR_VS20_RELADDR_A0_INVALID_INSTRUCTION = 711, // 2: "Only the mova instruction is allowed to write to the address register."
	D3DSVERR_VS30_RELADDR_A0_INVALID_INSTRUCTION = 712, // 2: "Only the mova instruction is allowed to write to the address register."
	D3DSVERR_VS30_MOVA_INVALID_DEST_REGTYPE = 713, // 2: "mova instruction can only write to the address register."
	D3DSVERR_PS30_PRED_SETP_INVALID_DST = 714, // 2: "The setp instruction must write to the predicate register."
	D3DSVERR_VS20_DST_INVALID_REGTYPE = 715, // 2: "Invalid reg type for dest param."
	D3DSVERR_VS20_PRED_WRITE_WITHOUT_SETP = 716, // 2: "The only instruction allowed to write to the predicate register is setp."
	D3DSVERR_VS20_PRED_SETP_INVALID_DST = 717, // 2: "The setp instruction must write to the predicate register."
	D3DSVERR_VS30_DST_INVALID_REGTYPE = 718, // 2: "Invalid reg type for dest param."
	D3DSVERR_VS30_PRED_WRITE_WITHOUT_SETP = 719, // 2: "The only instruction allowed to write to the predicate register is setp."
	D3DSVERR_VS30_PRED_SETP_INVALID_DST = 720, // 2: "The setp instruction must write to the predicate register."
	D3DSVERR_VS30_DST_REGNUM_OUT_OF_BOUNDS = 721, // 2: "Invalid dest reg num: %d. Max allowed for this reg type is %d."
	D3DSVERR_PS30_DST_SAT_INVALID_MODIFIER = 722, // 2: "%s instruction does not support _sat modifier."
	D3DSVERR_VS30_DST_INVALID_WRITEMOD = 723, // 2: "Invalid dst modifier for vertex shader."
	D3DSVERR_VS30_DST_DSTSHIFT_ILLEGAL = 724, // 2: "Dest shifts not allowed for vertex shaders."
	D3DSVERR_VS20_RELADDR_DST_ADDRESSING_ILLEGAL = 725, // 2: "Relative addressing of destination not permitted on destination in this shader model."
	D3DSVERR_VS30_DST_WRITEMASK_EMPTY = 726, // 2: "Dest write mask cannot be empty."
	D3DSVERR_VS30_RELADDR_DST_ADDRESSING_OUTREG_ONLY = 727, // 2: "Relative addressing of destination only permitted on output registers (o#)."
	D3DSVERR_VS30_RELADDR_DST_AL_REQUIRED = 728, // 2: "Relative addressing of o# register requires aL register."
	D3DSVERR_PS30_DEF_MUST_APPEAR_FIRST = 729, // 2: "def or dcl instructions must appear before other instructions."
	D3DSVERR_VS20_DEF_MUST_APPEAR_FIRST = 730, // 2: "def or dcl instructions must appear before other instructions."
	D3DSVERR_VS30_DEF_MUST_APPEAR_FIRST = 731, // 2: "def or dcl instructions must appear before other instructions."
	D3DSVERR_PS30_DEFI_INVALID_FORMAT = 732, // 2: "Destination for defi instruction must be i# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_VS20_DEF_WRITE_REGTYPE_INVALID = 733, // 2: "Destination for def instruction must be c# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_VS20_DEFI_INVALID_FORMAT = 734, // 2: "Destination for defi instruction must be i# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_VS30_DEF_WRITE_REGTYPE_INVALID = 735, // 2: "Destination for def instruction must be c# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_VS30_DEFI_INVALID_FORMAT = 736, // 2: "Destination for defi instruction must be i# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_VS30_DEF_REGISTER_OUT_OF_BOUNDS = 737, // 2: "Invalid const register num: %d. Max allowed is %d."
	D3DSVERR_VS20_RELADDR_ABSOLUTE_INPUTREG_INVALID_COMBINATION = 738, // 2: "Absolute and relative addressing of input registers cannot be combined in one instruction."
	D3DSVERR_VS20_RELADDR_ABSOLUTE_CONSTREG_INVALID_COMBINATION = 739, // 2: "Absolute and relative addressing of constant registers cannot be combined in one instruction."
	D3DSVERR_VS30_RELADDR_ABSOLUTE_INPUTREG_INVALID_COMBINATION = 740, // 2: "Absolute and relative addressing of input registers cannot be combined in one instruction."
	D3DSVERR_VS30_RELADDR_ABSOLUTE_CONSTREG_INVALID_COMBINATION = 741, // 2: "Absolute and relative addressing of constant registers cannot be combined in one instruction."
	D3DSVERR_VS20_RELADDR_DIFFERENT_INPUTREG_RELADDR = 742, // 2: "Different relative addressing of input registers cannot be combined in one instruction."
	D3DSVERR_VS20_RELADDR_DIFFERENT_CONSTREG_RELADDR = 743, // 2: "Different relative addressing of constant registers cannot be combined in one instruction."
	D3DSVERR_VS30_RELADDR_DIFFERENT_INPUTREG_RELADDR = 744, // 2: "Different relative addressing of input registers cannot be combined in one instruction."
	D3DSVERR_VS30_RELADDR_DIFFERENT_CONSTREG_RELADDR = 745, // 2: "Different relative addressing of constant registers cannot be combined in one instruction."
	D3DSVERR_VS20_RELADDR_ABSOLUTE_INPUTREG_INVALID_COMBINATION2 = 746, // 2: "Absolute and relative addressing of input registers cannot be combined in one instruction."
	D3DSVERR_VS20_RELADDR_ABSOLUTE_CONSTREG_INVALID_COMBINATION2 = 747, // 2: "Absolute and relative addressing of constant registers cannot be combined in one instruction."
	D3DSVERR_VS30_RELADDR_ABSOLUTE_INPUTREG_INVALID_COMBINATION2 = 748, // 2: "Absolute and relative addressing of input registers cannot be combined in one instruction."
	D3DSVERR_VS30_RELADDR_ABSOLUTE_CONSTREG_INVALID_COMBINATION2 = 749, // 2: "Absolute and relative addressing of constant registers cannot be combined in one instruction."
	D3DSVERR_VS30_READPORT_TEMPREG_LIMIT_EXCEEDED = 750, // 2: %d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d.
	D3DSVERR_VS30_READPORT_INPUTREG_LIMIT_EXCEEDED = 751, // 2: "%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d. "
	D3DSVERR_VS30_READPORT_CONSTREG_LIMIT_EXCDEEDED = 752, // 2: "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d. "
	D3DSVERR_VS30_READPORT_MATRIX_MULTIPLE_CONSTREG_READ = 753, // 2: "Multiple constant registers cannot be read by a matrix op."
	D3DSVERR_VS30_READPORT_MATRIX_MULTIPLE_INPUTREG_READ = 754, // 2: "Multiple input registers cannot be read by a matrix op."
	D3DSVERR_VS20_INSTSLOTS_EXCEEDED_TOTAL = 755, // 6: "Number of instruction slots used too high: %d. Max. allowed is %d."
	D3DSVERR_VS30_INSTSLOTS_EXCEEDED_TOTAL = 756, // 6: "Number of instruction slots used too high: %d. Max. allowed is %d."
	D3DSVERR_PS30_DST_DSTSHIFT_ILLEGAL = 757, // 2: "Instruction shifts not permitted."
	D3DSVERR_PS30_ODEPTH_INST_ILLEGAL = 758, // 2: "oDepth may not be written by the %s instruction."
	D3DSVERR_PS30_ODEPTH_ILLEGAL_WRITEMASK = 759, // 2: "Write to oDepth register must not specify any writemask. (Note, this is equivalent to using a full writemask) oDepth is a scalar output, however a specific rgba/xyzw channel does not apply -> the writemask is meaningless. "
	D3DSVERR_VERTDECL_POSITIONT0_REQUIRES_ALL_ELEMENTS_USE_STREAMNUM_0 = 760, // 6: "Transformed vertex declaration (containing usage+index D3DDECLUSAGE_POSITIONT,0) must only use stream 0 for all elements.  i.e. When vertex processing is disabled, only stream 0 can be used. "
	D3DSVERR_PS30_CRS_SRC_DST_COLLISION = 761, // 2: "Dest register for CRS cannot be the same as a source register."
	D3DSVERR_PS30_CRS_SRC_SWIZZLE_ILLEGAL = 762, // 2: "Swizzle not permitted on source paramters to CRS."
	D3DSVERR_PS30_CRS_INVALID_WRITE_MASK = 763, // 2: "Write mask for CRS must be one of: .x | .y | .z | .xy | .xz | .yz | .xyz (or rgba equivalent)"
	D3DSVERR_PS30_POW_SRC_DST_COLLISION = 764, // 2: "Dest register for POW cannot be the same as second source register."
	D3DSVERR_PS20_LRP_SRC_DST_COLLISION = 765, // 2: "Dest register for LRP cannot be the same as first or third source register."
	D3DSVERR_PS30_LRP_SRC_DST_COLLISION = 766, // 2: "Dest register for LRP cannot be the same as first or third source register."
	D3DSVERR_PS30_SINCOS_SRC_DST_COLLISION = 767, // 2: "Dest register for SINCOS cannot be the same as first source register."
	D3DSVERR_VS30_SINCOS_SRC_DST_COLLISION = 768, // 2: "Dest register for SINCOS cannot be the same as first source register."
	D3DSVERR_PS30_DCL_SAMPREG_ALREADY_DECLARED = 769, // 2: "Sampler %s%d already declared. "
	D3DSVERR_PS30_DCL_ILLEGAL_WRITEMASK = 770, // 2: "dcl %s# must not specify a writemask (equivalent to a full mask). "
	D3DSVERR_VS30_DCL_SAMPREG_ALREADY_DECLARED = 771, // 2: "Sampler %s%d already declared. "
	D3DSVERR_VS30_DCL_ILLEGAL_WRITEMASK = 772, // 2: "dcl %s# must not specify a writemask (equivalent to a full mask). "
	D3DSVERR_PS20_TEXLD_ILLEGAL_WRITEMASK = 773, // 2: "texld* must not specify a writemask (same as full mask). texld* instructions always write 4 components, including defaults if the source texture being sampled contains fewer than 4 components. "
	D3DSVERR_PS30_DST_WRITEMASK_EMPTY = 774, // 2: "Writemask cannot be empty."
	D3DSVERR_PS20_TEX_DEPENDENCY_EXCEEDS_THIRD_ORDER = 775, // 2: "Dependent tex-op sequence too long (%dth order). A 1st order dependent tex-op is a tex[ld*|kill] instruction in which either: (1) an r# reg is input (NOT t# reg), or (2) output r# reg was previously written, now being written AGAIN. A 2nd order dependent tex-op occurs if: a tex-op reads OR WRITES to an r# reg whose contents, BEFORE executing the tex-op, depend (perhaps indirectly) on the outcome of a 1st order dependent tex-op. An (n)th order dependent tex-op derives from an (n-1)th order tex-op. A given tex-op may be dependent to at most 3rd order (ps_2_0/x only)."
	D3DSVERR_VS30_DST_SCALAR_REQUIRES_REPLICATE_SWIZZLE = 776, // 2: "When writing to scalar output register, %s instruction must use replicate swizzle on source parameter(s), in order to select single component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	// 777
	// 778
	// 779
	// 780
	D3DSVERR_VS30_DST_SCALAR_INVALID_INSTRUCTION = 781, // 2: "%s instruction cannot write to scalar output register."
	// 782
	D3DSVERR_VS30_NRM_SRC_DST_COLLISION = 783, // 2: "Src and dest registers for NRM cannot be the same."
	D3DSVERR_VS30_NRM_DST_WRITEMASK_INVALID = 784, // 2: "Dest writemask for NRM must be .xyzw (default) or .xyz (or equivalent rgba notation)"
	D3DSVERR_VS30_CRS_DST_REGTYPE_INVALID = 785, // 2: "Dest register type for CRS must be temp (r#)."
	D3DSVERR_VS30_CRS_SRC_DST_COLLISION = 786, // 2: "Dest register for CRS cannot be the same as a source register."
	D3DSVERR_VS30_CRS_SRC_SWIZZLE_ILLEGAL = 787, // 2: "Swizzle not permitted on source paramters to CRS."
	D3DSVERR_VS30_CRS_INVALID_WRITE_MASK = 788, // 2: "Write mask for CRS must be one of: .x | .y | .z | .xy | .xz | .yz | .xyz (or rgba equivalent)"
	D3DSVERR_VS30_POW_SRC_DST_COLLISION = 789, // 2: "Dest register for POW cannot be the same as second source register."
	D3DSVERR_VS30_LRP_SRC_DST_COLLISION = 790, // 2: "Dest register for LRP cannot be the same as first or third source register."
	D3DSVERR_VS30_NRM_DST_REGTYPE_INVALID = 791, // 2: "Dest register type for NRM must be temp (r#)."
	D3DSVERR_VS30_POW_DST_REGTYPE_INVALD = 792, // 2: "Dest register type for POW must be temp (r#)."
	D3DSVERR_PS30_SRC_REQUIRES_REPLICATE_SWIZZLE = 793, // 2: "%s requires replicate swizzle for source parameter(s) in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_VS20_SRC_REQUIRES_REPLICATE_SWIZZLE = 794, // 2: "%s requires replicate swizzle for source parameter(s) in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_VS30_SRC_REQUIRES_REPLICATE_SWIZZLE = 795, // 2: "%s requires replicate swizzle for source parameter(s) in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_VS30_LRP_DST_REGTYPE_INVALID = 796, // 2: "Dest register type for LRP must be temp (r#)."
	D3DSVERR_VS30_SGN_SRC1_SRC2_COLLISION = 797, // 2: "Second and third source params for SGN must both be different temp (r#) registers."
	D3DSVERR_VS30_SGN_SRC0_COLLISION = 798, // 2: "First source param for SGN cannot be the same register as the second or third params."
	D3DSVERR_VS30_SGN_SRC1_SRC2_INVALID_SRCMOD_OR_SWIZZLE = 799, // 2: "Second and third source params for SGN cannot use a source selector, and cannot have a modifier. "
	D3DSVERR_VS_INST_DCL_INVALID_WRITEMASK = 800, // 2: "dcl must specify full writemask in this shader version (same as not specifying mask) for %s# registers."
	D3DSVERR_VS30_DCL_EMPTY_WRITEMASK = 801, // 2: "dcl can't specify empty writemask."
	D3DSVERR_VS_RELADDR_TOKEN_MISSING = 802, // 2: "Expected relative address token.  Aborting validation." // This is the same as error code 474
	D3DSVERR_VS_RELADDR_TOKEN_MISSING2 = 803, // 2: "Expected relative address token.  Aborting validation."
	D3DSVERR_VS_RELADDR_MISSING_REPLICATE_SWIZZLE2 = 804, // 2: "Relative address must specify a single component selector (.x, .y, .z or .w) to indicate relative address component. Aborting validation."
	D3DSVERR_VS_RELADDR_RESERVED_BIT_SET = 805, // 2: "Reserved bit(s) set in relative address token for source parameter %d!  Aborting validation." // This is the same as error code 476
	D3DSVERR_VS_RELADDR_RESERVED_BIT_SET2 = 806, // 2: "Reserved bit(s) set in relative address token for source parameter %d!  Aborting validation."
	D3DSVERR_VS30_DST_M_INVALID_WRITEMASK = 807, // 2: "%s instruction must use destination writemask: .%s"
	D3DSVERR_VS30_DST_M_SRC_REG_COLLISION = 808, // 2: "Dest register cannot be the same as first source register for m*x* instructions."
	D3DSVERR_VS30_DST_M_IMPLIED_SRC_REG_COLLISION = 809, // 2: "Dest register for m*x* instructions cannot be the same as one of the additional registers implied by the second source register."
	D3ESVERR_VS30_DST_SCALAR_INVALID_WRITE_MASK = 810, // 2: "Scalar output register must have full write mask."
	D3DSVERR_VS30_DST_M_SCALAR_DST = 811, // 2: "M*x* matrix instructions cannot write to scalar output register."
	D3DSVERR_PS20_FLOWCTRL_LABEL_BAD_PLACEMENT = 812, // 2: "Label is defined inside a subroutine or main program. Label must follow the ret instruction. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_LABEL_MUST_FOLLOW_RET = 813, // 2: "'label' is only permitted directly after a 'ret' instruction. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_LABEL_BAD_PLACEMENT = 814, // 2: "Label is defined inside a subroutine or main program. Label must follow the ret instruction. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_LABEL_BAD_PLACEMENT = 815, // 2: "Label is defined inside a subroutine or main program. Label must follow the ret instruction. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_LABEL_MUST_FOLLOW_RET = 816, // 2: "'label' is only permitted directly after a 'ret' instruction. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_LABEL_BAD_PLACEMENT = 817, // 2: "Label is defined inside a subroutine or main program. Label must follow the ret instruction. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_LABEL_VALUE_OUT_OF_RANGE = 818, // 2: "Subroutine label number, %d, is too large. Maximum label number is %d. Aborting shader validation."
	D3DSVERR_VS20_FLOWCTRL_LABEL_VALUE_OUT_OF_RANGE = 819, // 2: "Subroutine label number, %d, is too large. Maximum label number is %d. Aborting shader validation."
	D3DSVERR_VS30_FLOWCTRL_LABEL_VALUE_OUT_OF_RANGE = 820, // 2: "Subroutine label number, %d, is too large. Maximum label number is %d. Aborting shader validation."
	D3DSVERR_PS30_FLOWCTRL_LABEL_MULTIPLE_DEFINITIONS = 821, // 2: "Subroutine label number: %d already defined earlier. Aborting shader validation."
	D3DSVERR_VS20_FLOWCTRL_LABEL_MULTIPLE_DEFINITIONS = 822, // 2: "Subroutine label number: %d already defined earlier. Aborting shader validation."
	D3DSVERR_VS30_FLOWCTRL_LABEL_MULTIPLE_DEFINITIONS = 823, // 2: "Subroutine label number: %d already defined earlier. Aborting shader validation."
	D3DSVERR_PS30_FLOWCTRL_BACKWARDS_CALL = 824, // 2: "Cannot call subroutine label defined earlier in shader (label #%d in this case).  Subroutine call must reference label defined later in shader. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_BACKWARDS_CALL = 825, // 2: "Cannot call subroutine label defined earlier in shader (label #%d in this case).  Subroutine call must reference label defined later in shader. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_BACKWARDS_CALL = 826, // 2: "Cannot call subroutine label defined earlier in shader (label #%d in this case).  Subroutine call must reference label defined later in shader. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_LOOP_NESTING_LIMIT_EXCEEDED = 827, // 2: "Depth of loop nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_LOOP_NESTING_LIMIT_EXCEEDED = 828, // 2: "Depth of loop nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_LOOP_NESTING_LIMIT_EXCEEDED2 = 829, // 2: "Depth of loop nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_LOOP_NESTING_LIMIT_EXCEEDED = 830, // 2: "Depth of loop nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_UNMATCHED_ENDLOOP = 831, // 2: "'endloop' instruction does not match up to an 'loop'. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_UNMATCHED_ENDLOOP = 832, // 2: "'endloop' instruction does not match up to an 'loop'. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_RET_INSIDE_FLOW_CONTROL = 833, // 2: "'ret' instruction not permitted from inside any flow control block. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_RET_INSIDE_FLOW_CONTROL = 834, // 2: "'ret' instruction not permitted from inside any flow control block. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_RET_INSIDE_FLOW_CONTROL = 835, // 2: "'ret' instruction not permitted from inside any flow control block. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_UNMATCHED_ENDREP = 836, // 2: "'endrep' instruction does not match up to a 'rep'. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_UNMATCHED_ENDREP = 837, // 2: "'endrep' instruction does not match up to a 'rep'. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_UNMATCHED_ENDREP = 838, // 2: "'endrep' instruction does not match up to a 'rep'. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_UNMATCHED_ENDREP = 839, // 2: "'endrep' instruction does not match up to a 'rep'. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_ENDIF_UNMATCHED = 840, // 2: "'endif' instruction does not match up to an 'if' or 'else'. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_ENDIF_UNMATCHED = 841, // 2: "'endif' instruction does not match up to an 'if' or 'else'. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_ENDIF_UNMATCHED = 842, // 2: "'endif' instruction does not match up to an 'if' or 'else'. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_SUB_NESTING_LIMIT_EXCEEDED = 843, // 2: "Depth of subroutine call nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_LOOP_NESTING_EXCEEDS_DEVICE = 844, // 65538: "Compiled code results in loop nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_PS20_FLOWCTRL_IFC_NESTING_EXCEEDS_DEVICE = 845, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_PS20_FLOWCTRL_IFC_NESTING_LIMIT_EXCEEDED = 846, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_IF_NESTING_LIMIT_EXCEEDED = 847, // 2: "Depth of static 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_IFC_NESTING_EXCEEDS_DEVICE2 = 848, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_PS20_FLOWCTRL_IFC_NESTING_LIMIT_EXCEEDED2 = 849, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_SUB_NESTING_EXCEEDS_DEVICE = 850, // 65538: "Compiled code results in subroutine call nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_PS30_FLOWCTRL_SUB_NESTING_LIMIT_EXCEEDED = 851, // 2: "Depth of subroutine call nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_LOOP_NESTING_EXCEEDS_DEVICE = 852, // 65538: "Compiled code results in loop nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_PS30_FLOWCTRL_IFC_NESTING_EXCEEDS_DEVICE = 853, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_PS30_FLOWCTRL_IFC_NESTING_LIMIT_EXCEEDED = 854, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_IF_NESTING_EXCEEDS_DEVICE = 855, // 65538: "Compiled code results in static 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_PS30_FLOWCTRL_IF_NESTING_LIMIT_EXCEEDED = 856, // 2: "Depth of static 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_IFC_NESTING_EXCEEDS_DEVICE2 = 857, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_PS30_FLOWCTRL_IFC_NESTING_LIMIT_EXCEEDED2 = 858, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_SUB_NESTING_LIMIT_EXCEEDED = 859, // 2: "Depth of subroutine call nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_SUB_NESTING_EXCEEDS_DEVICE = 860, // 65538: "Compiled code results in subroutine nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VS20_FLOWCTRL_SUB_NESTING_LIMIT_EXCEEDED2 = 861, // 2: "Depth of subroutine call nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_LOOP_NESTING_EXCEEDS_DEVICE = 862, // 65538: "Compiled code results in loop nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VS20_FLOWCTRL_IFC_NESTING_LIMIT_EXCEEDED = 863, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_IFC_NESTING_EXCEEDS_DEVICE = 864, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VS20_FLOWCTRL_IFC_NESTING_LIMIT_EXCEEDED2 = 865, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_IF_NESTING_LIMIT_EXCEEDED = 866, // 2: "Depth of static 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_IF_NESTING_EXCEEDS_DEVICE = 867, // 65538: "Compiled code results in static 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VS20_FLOWCTRL_IF_NESTING_LIMIT_EXCEEDED2 = 868, // 2: "Depth of static 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_IFC_NESTING_LIMIT_EXCEEDED3 = 869, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_IFC_NESTING_EXCEEDS_DEVICE2 = 870, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VS20_FLOWCTRL_IFC_NESTING_LIMIT_EXCEEDED4 = 871, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_SUB_NESTING_EXCEEDS_DEVICE = 872, // 65538: "Compiled code results in subroutine call nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VS30_FLOWCTRL_SUB_NESTING_LIMIT_EXCEEDED = 873, // 2: "Depth of subroutine call nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_LOOP_NESTING_EXCEEDS_DEVICE = 874, // 65538: "Compiled code results in loop nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VS30_FLOWCTRL_IFC_NESTING_EXCEEDS_DEVICE2 = 875, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VS30_FLOWCTRL_IFC_NESTING_LIMIT_EXCEEDED2 = 876, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_IF_NESTING_EXCEEDS_DEVICE = 877, // 65538: "Compiled code results in static 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VS30_FLOWCTRL_IF_NESTING_LIMIT_EXCEEDED = 878, // 2: "Depth of static 'if' nesting exceeds limit of %d. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_BREAKCMP_NESTING_EXCEEDS_DEVICE = 879, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s) (due to conditional break that counts towards the same limit). "
	D3DSVERR_PS20_FLOWCTRL_BREAKCMP_NESTING_LIMIT_EXCEEDED = 880, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d, due to break_cmp that counts towards same limit. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_RET_BAD_PLACEMENT = 881, // 2: "A 'ret' instruction must be followed by either (1) the end of the shader or (2) a 'label' instruction. Aborting shader validation."
	D3DSVERR_VS20_FLOWCTRL_RET_BAD_PLACEMENT = 882, // 2: "A 'ret' instruction must be followed by either (1) the end of the shader or (2) a 'label' instruction. Aborting shader validation."
	D3DSVERR_VS30_FLOWCTRL_RET_BAD_PLACEMENT = 883, // 2: "A 'ret' instruction must be followed by either (1) the end of the shader or (2) a 'label' instruction. Aborting shader validation."
	D3DSVERR_PS30_FLOWCTRL_UNDEFINED_LABEL = 884, // 6: "Subroutine with label #%d called, but never defined."
	D3DSVERR_VS20_FLOWCTRL_UNDEFINED_LABEL = 885, // 6: "Subroutine with label #%d called, but never defined."
	D3DSVERR_VS30_FLOWCTRL_UNDEFINED_LABEL = 886, // 6: "Subroutine with label #%d called, but never defined."
	D3DSVERR_PS30_FLOWCTRL_UNREFERENCED_LABEL = 887, // 6: "Subroutine label #%d never referenced."
	D3DSVERR_VS20_FLOWCTRL_UNREFERENCED_LABEL = 888, // 6: "Subroutine label #%d never referenced."
	D3DSVERR_VS30_FLOWCTRL_UNREFERENCED_LABEL = 889, // 6: "Subroutine label #%d never referenced."
	D3DSVERR_PS30_FLOWCTRL_UNCLOSED_SUBROUTINE = 890, // 6: "End of shader reached without 'ret' to terminate subroutine."
	D3DSVERR_VS20_FLOWCTRL_UNCLOSED_SUBROUTINE = 891, // 6: "End of shader reached without 'ret' to terminate subroutine."
	D3DSVERR_VS30_FLOWCTRL_UNCLOSED_SUBROUTINE = 892, // 6: "End of shader reached without 'ret' to terminate subroutine."
	D3DSVERR_PS20_FLOWCTRL_ELSE_ALREADY_USED = 893, // 2: "'else' already used for current 'if' construct. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_BREAK_UNMATCHED = 894, // 2: "'break' instruction not within a local rep/endrep construct. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_ELSE_UNMATCHED = 895, // 2: "'else' instruction does not match up to an 'if'. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_ELSE_ALREADY_USED = 896, // 2: "'else' already used for current 'if' construct. Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_BREAK_UNMATCHED = 897, // 2: "'break' instruction not within a local loop/rep construct. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_ELSE_UNMATCHED = 898, // 2: "'else' instruction does not match up to an 'if'. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_ELSE_ALREADY_USED = 899, // 2: "'else' already used for current 'if' construct. Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_BREAK_UNMATCHED = 900, // 2: "'break' instruction not within a local loop/rep construct. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_ELSE_UNMATCHED = 901, // 2: "'else' instruction does not match up to an 'if'. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_ELSE_ALREADY_USED = 902, // 2: "'else' already used for current 'if' construct. Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_BREAK_UNMATCHED = 903, // 2: "'break' instruction not within a local loop/rep construct. Aborting shader validation. "
	D3DSVERR_PS20_FLOWCTRL_UNCLOSED_IF = 904, // 6: "End of shader reached and 'if' construct was not completed with 'else'/'endif'. "
	D3DSVERR_PS30_FLOWCTRL_UNCLOSED_CONSTRUCT_BLOCK = 905, // 6: "End of shader reached and '%s' construct was not completed with a '%s'. "
	D3DSVERR_PS30_FLOWCTRL_UNCLOSED_IF = 906, // 6: "End of shader reached and 'if' construct was not completed with 'else'/'endif'. "
	D3DSVERR_VS20_FLOWCTRL_UNCLOSED_CONSTRUCT_BLOCK = 907, // 6: "End of shader reached and '%s' construct was not completed with a '%s'. "
	D3DSVERR_VS20_FLOWCTRL_UNCLOSED_IF = 908, // 6: "End of shader reached and 'if' construct was not completed with 'else'/'endif'. "
	D3DSVERR_VS30_FLOWCTRL_UNCLOSED_CONSTRUCT_BLOCK = 909, // 6: "End of shader reached and '%s' construct was not completed with a '%s'. "
	D3DSVERR_VS30_FLOWCTRL_UNCLOSED_IF = 910, // 6: "End of shader reached and 'if' construct was not completed with 'else'/'endif'. "
	D3DSVERR_PS30_SAT_TEX_INVALID_MODIFIER = 911, // 2: "_sat not permitted on tex* instructions."
	D3DSVERR_PS30_SAT_FRC_INVALID_MODIFIER = 912, // 2: "_sat not permitted with frc instruction."
	D3DSVERR_PS20_SRC_NOT_PREDREG = 913, // 2: "On current device, %s requires the condition%s parameter to be predicate register (p0). "
	D3DSVERR_PS20_SRC_NOT_CONDITIONAL_REGTYPE = 914, // 2: "%s requires the condition parameter%s to be boolean constant register (b#), or predicate register (p0). "
	D3DSVERR_PS20_SRC_NOT_BOOLREG = 915, // 2: "%s requires the condition parameter%s to be boolean constant register (b#). "
	D3DSVERR_PS30_SRC1_NOT_CONDITIONAL_REGTYPE = 916, // 2: "%s requires second source parameter (the condition) to be boolean constant register (b#), or predicate register (p0). "
	D3DSVERR_PS30_SRC_NOT_CONDITIONAL_REGTYPE = 917, // 2: "%s requires parameter (the branch condition) to be boolean constant register (b#), or predicate register (p0). "
	D3DSVERR_VS20_SRC1_NOT_BOOLREG = 918, // 2: "%s requires second source parameter (the condition) to be boolean constant register (b#). "
	D3DSVERR_VS20_SRC1_NOT_CONDITIONAL_REGTYPE = 919, // 2: "%s requires second source parameter (the condition) to be boolean constant register (b#), or predicate register (p0). "
	D3DSVERR_VS20_SRC_NOT_CONDITIONAL_REGTYPE = 920, // 2: "%s requires parameter (the branch condition) to be boolean constant register (b#), or predicate register (p0). "
	D3DSVERR_VS20_SRC_NOT_BOOLREG = 921, // 2: "%s requires parameter (the branch condition) to be boolean constant register (b#). "
	D3DSVERR_VS30_SRC1_NOT_CONDITIONAL_REGTYPE = 922, // 2: "%s requires second source parameter (the condition) to be boolean constant register (b#), or predicate register (p0). "
	D3DSVERR_VS30_SRC_NOT_CONDITIONAL_REGTYPE = 923, // 2: "%s requires parameter (the branch condition) to be boolean constant register (b#), or predicate register (p0). "
	D3DSVERR_VS20_SRC0_NOT_AL = 924, // 2: "loop requires first parameter to be loop counter (aL). "
	D3DSVERR_VS30_SRC0_NOT_AL = 925, // 2: "loop requires first parameter to be loop counter (aL). "
	D3DSVERR_PS20_BREAKP_SRC0_NOT_PREDREG = 926, // 2: "breakp requires parameter to be predicate register (p0). "
	D3DSVERR_PS20_SRC0_NOT_LABELREG = 927, // 2: "%s requires the first parameter to be a label (l#). "
	D3DSVERR_PS20_SRC_NOT_INTREG = 928, // 2: "rep requires parameter to be integer constant register (i#). "
	D3DSVERR_PS30_SRC_NOT_LABELREG = 929, // 2: "%s instruction requires parameter to be label (l#). "
	D3DSVERR_PS30_BREAKP_SRC0_NOT_PREDREG = 930, // 2: "breakp requires parameter to be predicate register (p0). "
	D3DSVERR_PS30_SRC0_NOT_LABELREG = 931, // 2: "%s requires %s parameter to be label (l#). "
	D3DSVERR_PS30_SRC_NOT_INTREG = 932, // 2: "%s requires %s parameter to be integer constant register (i#). "
	D3DSVERR_VS20_SRC_NOT_LABELREG = 933, // 2: "%s instruction requires parameter to be label (l#). "
	D3DSVERR_VS20_BREAKP_SRC0_NOT_PREDREG = 934, // 2: "breakp requires parameter to be predicate register (p0). "
	D3DSVERR_VS20_SRC0_NOT_LABELREG = 935, // 2: "%s requires %s parameter to be label (l#). "
	D3DSVERR_VS20_SRC_NOT_INTREG = 936, // 2: "%s requires %s parameter to be integer constant register (i#). "
	D3DSVERR_VS30_SRC_NOT_LABELREG = 937, // 2: "%s instruction requires parameter to be label (l#). "
	D3DSVERR_VS30_BREAKP_SRC0_NOT_PREDREG = 938, // 2: "breakp requires parameter to be predicate register (p0). "
	D3DSVERR_VS30_SRC0_NOT_LABELREG = 939, // 2: "%s requires %s parameter to be label (l#). "
	D3DSVERR_VS30_SRC_NOT_INTREG = 940, // 2: "%s requires %s parameter to be integer constant register (i#). "
	D3DSVERR_PS20_PRED_MUST_USE_REPLICATE_SWIZZLE = 941, // 2: "When predicate register is used as the condition for a %s instruction, a replicate swizzle must be specified, to select a component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_PS20_SRC_MUST_USE_DEFAULT_SWIZZLE = 942, // 2: "Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.) "
	D3DSVERR_PS20_SRC_BOOLREG_MUST_USE_DEFAULT_SWIZZLE = 943, // 2: "Const bool (b#) parameter to %s instruction must specify default swizzle (.xyzw, or none specified.) "
	D3DSVERR_PS20_P0_MUST_USE_REPLICATE_SWIZZLE = 944, // 2: "Predicate register (p0) parameter to %s instruction must specify replicate swizzle in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_PS30_SRC_MUST_USE_DEFAULT_SWIZZLE_OR_PRED_REPLICATE_SWIZZLE = 945, // 2: "Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.).  The exception is if the condition is the predicate register, p0, in which case a replicate swizzle must be used in order to select a component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_PS30_PRED_MUST_USE_REPLICATE_SWIZZLE = 946, // 2: "When predicate register is used as the condition for a %s instruction, a replicate swizzle must be specified, to select a component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_PS30_SRC_MUST_USE_DEFAULT_SWIZZLE = 947, // 2: "Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.) "
	D3DSVERR_PS30_SRC_BOOLREG_MUST_USE_DEFAULT_SWIZZLE = 948, // 2: "Const bool (b#) parameter to %s instruction must specify default swizzle (.xyzw, or none specified.) "
	D3DSVERR_PS30_P0_MUST_USE_REPLICATE_SWIZZLE = 949, // 2: "Predicate register (p0) parameter to %s instruction must specify replicate swizzle in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_VS20_SRC_MUST_USE_DEFAULT_SWIZZLE_OR_PRED_REPLICATE_SWIZZLE = 950, // 2: "Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.).  The exception is (on shader version > vs_2_0) if the condition is the predicate register, p0, in which case a replicate swizzle must be used in order to select a component. i.e. .x | .y | .z | .w (or rgba equivalent) "
	D3DSVERR_VS20_SRC_MUST_USE_DEFAULT_SWIZZLE = 951, // 2: "Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.).  The exception is if the condition is the predicate register, p0, in which case a replicate swizzle must be used in order to select a component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_VS20_PRED_MUST_USE_REPLICATE_SWIZZLE = 952, // 2: "When predicate register is used as the condition for a %s instruction, a replicate swizzle must be specified, to select a component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_VS20_SRC_MUST_USE_DEFAULT_SWIZZLE2 = 953, // 2: "Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.) "
	D3DSVERR_VS20_SRC_BOOLREG_MUST_USE_DEFAULT_SWIZZLE = 954, // 2: "Const bool (b#) parameter to %s instruction must specify default swizzle (.xyzw, or none specified.) "
	D3DSVERR_VS20_P0_MUST_USE_REPLICATE_SWIZZLE = 955, // 2: "Predicate register (p0) parameter to %s instruction must specify replicate swizzle in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_VS30_SRC_MUST_USE_DEFAULT_SWIZZLE_OR_PRED_REPLICATE_SWIZZLE = 956, // 2: "Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.).  The exception is if the condition is the predicate register, p0, in which case a replicate swizzle must be used in order to select a component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_VS30_PRED_MUST_USE_REPLICATE_SWIZZLE = 957, // 2: "When predicate register is used as the condition for a %s instruction, a replicate swizzle must be specified, to select a component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_VS30_SRC_MUST_USE_DEFAULT_SWIZZLE = 958, // 2: "Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.) "
	D3DSVERR_VS30_SRC_BOOLREG_MUST_USE_DEFAULT_SWIZZLE = 959, // 2: "Const bool (b#) parameter to %s instruction must specify default swizzle (.xyzw, or none specified.) "
	D3DSVERR_VS30_P0_MUST_USE_REPLICATE_SWIZZLE = 960, // 2: "Predicate register (p0) parameter to %s instruction must specify replicate swizzle in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_PS30_DP2ADD_SRC2_SCALAR_REQUIRES_REPLICATE_SWIZZLE = 961, // 2: "Third source parameter for dp2add must use a replicate swizzle (.r, .g, .b, .a) to select a scalar component."
	D3DSVERR_VS20_RELADDR_INVALID_ADDRESS_REGTYPE = 962, // 2: "Relative address register must be a# register or aL register (%s source param)."
	D3DSVERR_VS30_RELADDR_CONSTREG_INVALID_ADDRESS_REGTYPE = 963, // 2: "Relative address register for constant (c#) must be a# register or aL register (%s source param)."
	D3DSVERR_VS30_RELADDR_INPUTREG_SRC_AL_REQUIRED = 964, // 2: "Relative address for input (v#) can only be aL register (%s source param)."
	D3DSVERR_VS20_AL_REGNUM_OUT_OF_RANGE = 965, // 2: "Invalid register number, %d, specified for aL register. Max # supported is %d (%s source param)."
	D3DSVERR_VS30_AL_REGNUM_OUT_OF_RANGE = 966, // 2: "Invalid register number, %d, specified for aL register. Max # supported is %d (%s source param)."
	D3DSVERR_VS30_A_REGNUM_OUT_OF_RANGE = 967, // 2: "Invalid register number, %d, specified for a# (address) register. Max # supported is %d (%s source param)."
	D3DSVERR_PS20_DCL_MODIFIERS_ILLEGAL = 968, // 2: "dcl %s# does not support any modifiers. "
	D3DSVERR_PS30_DCL_MODIFIERS_UNSUPPORTED = 969, // 2: "dcl for %s register does not support any modifiers. "
	D3DSVERR_PS30_DCL_INVALID_MODIFIER = 970, // 2: "dcl %s# only supports the (optional) _pp modifier (partial precision hint), and/or the _centroid modifier (relevant to multisampling). No other modifiers supported."
	D3DSVERR_PS30_DCL_USAGE_UNSPECIFIED = 971, // 2: "dcl for input v# register must specify usage+index (semantic). i.e. dcl_texcoord5 v%d. Note that the semantics position0, positiont0, psize0, tessfactor(n) and sample(n) are not permitted."
	D3DSVERR_PS30_DCL_POSITIONT0_INVALID = 972, // 2: "dcl usage+index positiont0 cannot be used in a pixel shader."
	D3DSVERR_PS30_DCL_TESSFACTOR_INVALID = 973, // 2: "dcl usage 'tessfactor' is not avaliable to the pixel shader. "
	D3DSVERR_PS30_DCL_SAMPLE_INVALID = 974, // 2: "dcl usage 'sample' is not avaliable to the pixel shader. "
	D3DSVERR_VS_DCL_TESSFACTOR_INVALID = 975, // 2: "dcl usage 'tessfactor' is not permitted for vertex input shaders."
	D3DSVERR_VS_DCL_POSITIONT0_INPUT_INVALID = 976, // 2: "Input cannot be dcl'd with usage+index positiont0, as vertex data containing this semantic has special meaning to the API: skip vertex processing altogether."
	D3DSVERR_VS30_DCL_TESSFACTOR_INVALID = 977, // 2: "dcl usage 'tessfactor' is not permitted for vertex shader input registers."
	D3DSVERR_VS30_DCL_POSITIONT0_INPUT_INVALID = 978, // 2: "Input cannot be dcl'd with usage+index positiont0, as vertex data containing this semantic has special meaning to the API: skip vertex processing altogether."
	D3DSVERR_VS30_DCL_POSITIONT0_OUTPUT_INVALID = 979, // 2: "Vertex shader output is not permitted to be dcl'd with the usage+index positiont0."
	D3DSVERR_VS30_DCL_TESSFACTOR_OUTPUT_INVALID = 980, // 2: "Vertex shader output dcl with usage 'tessfactor' must have usage index 0, and register must have .x write mask. This semantic is for special purpose use only: creating vertex data that is to be used with tesselation, where a scalar tessfactor is needed.  If you are not doing tesselation, do not bother using this semantic. "
	D3DSVERR_VS30_DCL_PSIZE0_OUTPUT_INVALID = 981, // 2: "Output register dcl'd with usage+index psize0 takes as special meaning as a scalar, so no writemask must be specified (identical to full write mask). In addition, no other semantics may declared for the same output register as one assigned to psize0. "
	D3DSVERR_VS30_DCL_SAMPLE_OUTPUT_INVALID = 982, // 2: "Output register cannot be dcl'd with usage 'sample'."
	D3DSVERR_VS30_SINCOS_DST_INVALID_WRITEMASK = 983, // 2: "Dest mask for SINCOS must be one of: .x | .y | .xy "
	D3DSVERR_PS30_REGISTER_COMPONENTS_UNDECLARED = 984, // 2: "Component%s of register %s%d being read, but not declared. v# registers must be declared using dcl statement(s) (down to the component level). Affected components (*): %s"
	D3DSVERR_PS30_VPOS_COMPONENTS_UNDECLARED = 985, // 2: "Component(s) of register vPos being read, but not declared. vPos must be declared using a dcl statement. Affected components (*): %s"
	D3DSVERR_PS30_VFACE_UNDECLARED = 986, // 2: "vFace being read, but not declared. vFace must be declared if it is used:  dcl vFace"
	D3DSVERR_PS30_DEFI_REGISTER_OUT_OF_BOUNDS = 987, // 2: "Invalid constant integer (i#) register num: %d. Max allowed is %d."
	D3DSVERR_VS20_DEFI_REGISTER_OUT_OF_BOUNDS = 988, // 2: "Invalid constant integer (i#) register num: %d. Max allowed is %d."
	D3DSVERR_VS30_DEFI_REGISTER_OUT_OF_BOUNDS = 989, // 2: "Invalid constant integer (i#) register num: %d. Max allowed is %d."
	D3DSVERR_PS30_FLOWCTRL_INTREG_X_NEGATIVE = 990, // 2: "i%d.x (which represents loop or rep iteration count) cannot be negative. i%d.x is currently def'd as %d. "
	D3DSVERR_VS20_FLOWCTRL_INTREG_X_NEGATIVE = 991, // 2: "i%d.x (which represents loop or rep iteration count) cannot be negative. i%d.x is currently def'd as %d. "
	D3DSVERR_VS30_FLOWCTRL_INTREG_X_NEGATIVE = 992, // 2: "i%d.x (which represents loop or rep iteration count) cannot be negative. i%d.x is currently def'd as %d. "
	D3DSVERR_PS20_FLOWCTRL_INTREG_YZW_RESERVED = 993, // 2: "i%d.yzw have no meaning in this shader model; they must simply be 0. "
	D3DSVERR_PS20_DEFB_INVALID_VALUE = 994, // 2: "b%d must only be defined as true (0x00000001) or false (0x00000000). "
	D3DSVERR_PS30_FLOWCTRL_INTREG_X_OUT_OF_BOUNDS = 995, // 2: "i%d.x (which represents loop or rep iteration count) cannot be greater than %d. i%d.x is currently def'd as %d. "
	D3DSVERR_PS30_FLOWCTRL_INTREG_W_RESERVED = 996, // 2: "i%d.w has no meaning; it must simply be 0. "
	D3DSVERR_PS30_DEFB_INVALID_VALUE = 997, // 2: "b%d must only be defined as true (0x00000001) or false (0x00000000). "
	D3DSVERR_VS20_FLOWCTRL_INTREG_X_OUT_OF_BOUNDS = 998, // 2: "i%d.x (which represents loop or rep iteration count) cannot be greater than %d. i%d.x is currently def'd as %d. "
	D3DSVERR_VS20_FLOWCTRL_INTREG_W_RESERVED = 999, // 2: "i%d.w has no meaning; it must simply be 0. "
	D3DSVERR_VS20_DEFB_INVALID_VALUE = 1000, // 2: "b%d must only be defined as true (0x00000001) or false (0x00000000). "
	D3DSVERR_VS30_FLOWCTRL_INTREG_X_OUT_OF_BOUNDS = 1001, // 2: "i%d.x (which represents loop or rep iteration count) cannot be greater than %d. i%d.x is currently def'd as %d. "
	D3DSVERR_VS30_FLOWCTRL_INTREG_W_RESERVED = 1002, // 2: "i%d.w has no meaning; it must simply be 0. "
	D3DSVERR_VS30_DEFB_INVALID_VALUE = 1003, // 2: "b%d must only be defined as true (0x00000001) or false (0x00000000). "
	D3DSVERR_VS20_FLOWCTRL_INTREG_Y_OUT_OF_BOUNDS = 1004, // 2: "i%d.y (which represents loop initial value) must be in the range [0, %d]. i%d.y is currently def'd as %d. "
	D3DSVERR_VS30_FLOWCTRL_INTREG_Y_OUT_OF_BOUNDS = 1005, // 2: "i%d.y (which represents loop initial value) must be in the range [0, %d]. i%d.y is currently def'd as %d. "
	D3DSVERR_VS20_FLOWCTRL_INTREG_Z_OUT_OF_RANGE = 1006, // 2: "i%d.z (which represents loop step value) must be in the range [-%d, %d]. i%d.z is currently def'd as %d. "
	D3DSVERR_VS30_FLOWCTRL_INTREG_Z_OUT_OF_RANGE = 1007, // 2: "i%d.z (which represents loop step value) must be in the range [-%d, %d]. i%d.z is currently def'd as %d. "
	D3DSVERR_PS30_DEFB_REGISTER_OUT_OF_BOUNDS = 1008, // 2: "Invalid constant bool (b#) register num: %d. Max allowed is %d."
	D3DSVERR_VS20_DEFB_REGISTER_OUT_OF_BOUNDS = 1009, // 2: "Invalid constant bool (b#) register num: %d. Max allowed is %d."
	D3DSVERR_VS30_DEFB_REGISTER_OUT_OF_BOUNDS = 1010, // 2: "Invalid constant bool (b#) register num: %d. Max allowed is %d."
	D3DSVERR_PS30_DEFB_INVALID_FORMAT = 1011, // 2: "Destination for defb instruction must be b# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_VS20_DEFB_INVALID_FORMAT = 1012, // 2: "Destination for defb instruction must be b# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_VS30_DEFB_INVALID_FORMAT = 1013, // 2: "Destination for defb instruction must be b# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine)."
	D3DSVERR_PS30_DST_M_INVALID_WRITEMASK = 1014, // 2: "%s instruction must use destination writemask: .%s"
	D3DSVERR_PS30_DST_M_SRC_REG_COLLISION = 1015, // 2: "Dest register cannot be the same as first source register for m*x* instructions."
	D3DSVERR_PS30_DST_M_IMPLIED_SRC_REG_COLLISION = 1016, // 2: "Dest register for m*x* instructions cannot be the same as one of the additional registers implied by the second source register."
	D3DSVERR_PS30_READPORT_MATRIX_MULTIPLE_CONSTREG_READ = 1017, // 2: "Multiple constant registers cannot be read by a matrix op."
	D3DSVERR_PS30_READPORT_MATRIX_MULTIPLE_INPUTREG_READ = 1018, // 2: "Multiple input registers cannot be read by a matrix op."
	D3DSVERR_PS30_DST_INVALID_WRITEMOD = 1019, // 2: "Invalid instruction modifier."
	D3DSVERR_VS_DCL_MUST_APPEAR_FIRST = 1020, // 2: "def and dcl instructions must appear before other instructions."
	D3DSVERR_VS30_INST_DCL_USAGENUM_OUT_OF_RANGE = 1021, // 2: "dcl usage index, %d, is too high.  Max allowed is %d."
	D3DSVERR_PS20_FLOWCTRL_IF_NESTING_EXCEEDS_DEVICE = 1022, // 65538: "Compiled code results in static 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). "
	// 1023
	// 1024
	// 1025
	// 1026
	// 1027
	// 1028
	// 1029
	// 1030
	// 1031
	// 1032
	// 1033
	// 1034
	// 1035
	// 1036
	// 1037
	D3DSVERR_PS20_READPORT_SAME_CONSTREG_LIMIT_EXCDEEDED = 1038, // 2: "%d constant registers (c#) read by instruction.  Max. constant registers readable per instruction (even if they are the same) is %d.  This is in addition to the read port limit of %d for constants, which restricts how many *different* constants can be read. (There is one exception: none of this applies to the SINCOS macro instruction.)"
	D3DSVERR_VERTDECL_FVF_STREAMNUM_OUT_OF_RANGE = 1039, // 4: "Declaration can't map to fixed function FVF because nonzero stream index is used. "
	D3DSVERR_VERTDECL_FVF_INVALID_ELEMENTS = 1040, // 4: "Declaration can't map to fixed function FVF because there are too many usage+index pairs that are not valid for fixed function. To clarify: For a vertex declaration to map to fixed function, all individual elements with usage+index pairs valid for fixed function must appear contiguously starting from the first element.  Remaining elements at the end do not have to be valid for fixed function, as long as there are few enough that they can be aliased internally to texcoord(n), texcoord(n+1) etc. up to max. texcoord7 (thereby appearing to conform to an FVF, although the aliased values should not be used). "
	D3DSVERR_VERTDECL_DX8_NONZERO_STREAM_ELEMENTS_UNMAPPED = 1041, // 6: "Declaration can't map to fixed function on dx8 driver because there is a nonzero stream index AND there are element(s) that do not map to FVF. "
	D3DSVERR_VERTDECL_DX8_UNMAPPABLE_ELEMENTS = 1042, // 6: "Declaration can't map to fixed function on dx8 driver because there are both (a) elements with usage+index pairs that are not valid for dx8 driver and (b) generation methods other than DEFAULT in the same decl. For a vertex declaration to map to fixed funtion on dx8 drvier, all individual elements with usage+index pairs valid for dx8 must appear contiguously starting from the first element.  Remaining elements at the end do not have to be valid for fixed function, as long as there are few enough that they can be aliased internally to texcoord(n), texcoord(n+1) etc. up to max. texcoord7 (thereby appearing to conform to an FVF, although the aliased values should not be used). Additionally, when such aliasing occurs, all elements in the decl are then required to simply use generation method D3DDECLMETHOD_DEFAULT, for mapping to fixed function to work."
	D3DSVERR_PS30_FLOWCTRL_BREAKCMP_NESTING_EXCEEDS_DEVICE = 1043, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s) (due to conditional break that counts towards the same limit). "
	D3DSVERR_VS20_FLOWCTRL_BREAKCMP_NESTING_EXCEEDS_DEVICE = 1044, // 65538: "Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s) (due to conditional break that counts towards the same limit). "
	D3DSVERR_PS30_CONSTREG_ABS_CONSISTENCY = 1045, // 2: "When constant registers are read multiple times in a single instruction, the _abs modifier must either be present on all of the constants, or none of them. "
	D3DSVERR_VS30_CONSTREG_ABS_CONSISTENCY = 1046, // 2: "When constant registers are read multiple times in a single instruction, the _abs modifier must either be present on all of the constants, or none of them. "
	D3DSVERR_PS20_FLOWCTRL_CALLNZ_NESTING_EXCEEDS_DEVICE = 1047, // 65538: "Compiled code results in dynamic flow control nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_PS20_FLOWCTRL_CALLNZ_NESTING_LIMIT_EXCEEDED = 1048, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d (callnz with predicate counts as a dynamic 'if' nesting level). Aborting shader validation. "
	D3DSVERR_PS30_FLOWCTRL_CALLNZ_NESTING_EXCEEDS_DEVICE = 1049, // 65538: "Compiled code results in dynamic flow control nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_PS30_FLOWCTRL_CALLNZ_NESTING_LIMIT_EXCEEDED = 1050, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d (callnz with predicate counts as a dynamic 'if' nesting level). Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_CALLNZ_NESTING_LIMIT_EXCEEDED = 1051, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d (callnz with predicate counts as a dynamic 'if' nesting level). Aborting shader validation. "
	D3DSVERR_VS20_FLOWCTRL_CALLNZ_NESTING_EXCEEDS_DEVICE = 1052, // 65538: "Compiled code results in dynamic flow control nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VS20_FLOWCTRL_CALLNZ_NESTING_LIMIT_EXCEEDED2 = 1053, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d (callnz with predicate counts as a dynamic 'if' nesting level). Aborting shader validation. "
	D3DSVERR_VS30_FLOWCTRL_CALLNZ_NESTING_EXCEEDS_DEVICE = 1054, // 65538: "Compiled code results in dynamic flow control nesting depth that exceeds limit of %d for target (%s). "
	D3DSVERR_VS30_FLOWCTRL_CALLNZ_NESTING_LIMIT_EXCEEDED = 1055, // 2: "Depth of dynamic 'if' nesting exceeds limit of %d (callnz with predicate counts as a dynamic 'if' nesting level). Aborting shader validation. "
	D3DSVERR_VERTDECL_DUPLICATE_OFFSET_UNSUPPORTED_ON_DEVICE = 1056, // 4: "Vertex element offset is equal to the previous element offset, but device does not support it (D3DDEVCAPS2_VERTEXELEMENTSCANSHARESTREAMOFFSET is not set). Offset into stream #%d specified as %d. Expected offset to be at least %d."
	D3DSVERR_VS30_INSTSLOTS_EXCEEDED_TARGET_TOTAL = 1057, // 65542: "Compiled shader code uses too many instruction slots (%d). Max. allowed by the target (%s), including cap for instruction limit, is %d."
	D3DSVERR_VS30_INSTSLOTS_EXCEEDED_TOTAL2 = 1058, // 6: "Number of instruction slots used too high: %d. Max. allowed is %d."
	D3DSVERR_VERTDECL_FVF_ELEMENT_FVF_ORDER = 1059, // 4: "On a device that does not support ps_3_0, a transformed vertex declaration must specify elements in FVF order. "
	D3DSVERR_VERTDECL_POSITION0_POSITIONT0_COLLISION = 1060, // 6: "The usage+index pairs: (D3DDECLUSAGE_POSITION,0) and (D3DDECLUSAGE_POSITIONT,0) cannot both be present in a single vertex declaration. "
	D3DSVERR_PS30_SAT_SINCOS_INVALID_MODIFIER = 1061, // 2: "_sat not permitted with SINCOS instruction."
	D3DSVERR_PS30_ODEPTH_REQUIRES_REPLICATE_SWIZZLE = 1062, // 2: "When writing to oDepth, %s instruction must use replicate swizzle on source parameter(s), in order to select single component. i.e. .x | .y | .z | .w (or rgba equivalent)"
	D3DSVERR_PS30_VPOS_READ_ZW = 1063, // 2: "vPos does not have .z or .w channels in this shader model. Attempt to read following unavailable component(s) (*): %s"
	D3DSVERR_VS30_SRC0_INVALID_SRCMOD_TEX = 1064, // 2: "(%s source param) Source modifier not allowed on texcoord for texldl."
	D3DSVERR_VERTDECL_ELEMENT_OFFSET_MISALIGNED = 1065, // 4: "Offset must be multiple of DWORD size (4 bytes). Encountered offset: %d"
	D3DSVERR_PS30_SAT_SETP_INVALID_MODIFIER = 1066, // 2: "_sat not permitted with setp instruction."
	D3DSVERR_PS30_DCL_MULTIPLE_USAGES_CENTROID_DISCREPANCY = 1067, // 2: "When multple usages are declared for various components of a given input v# register, the _centroid hint can only be specified on either (a) all usages declared for the register, or (b) on none of them.  Also note that the usage 'color' (with any index) has special behavior: even if the centroid hint is not specified for color, it is assumed to be set. "
	D3DSVERR_PS20_PRED_ODEPTH_INVALID_SWIZZLE = 1068, // 2: "When writing to oDepth with predication, p0 must use a replicate swizzle to select a single component: .x | .y | .z | .w"
	D3DSVERR_PS30_PRED_ODEPTH_INVALID_SWIZZLE = 1069, // 2: "When writing to oDepth with predication, p0 must use a replicate swizzle to select a single component: .x | .y | .z | .w"
	D3DSVERR_VS20_PRED_SCALAR_DST_REQUIRES_REPLICATE_SWIZZLE = 1070, // 2: "When writing to scalar output (oFog, oPts) with predication, p0 must use a replicate swizzle to select a single component: .x | .y | .z | .w"
	D3DSVERR_VS30_PRED_SCALAR_DST_REQUIRES_REPLICATE_SWIZZLE = 1071, // 2: "When writing to scalar output (psize) with predication, p0 must use a replicate swizzle to select a single component: .x | .y | .z | .w"
	D3DSVERR_PS30_DCL_MULTIPLE_USAGES_CENTROID_DISCREPANCY2 = 1072, // 2: "When multple usages are declared for various components of a given input v# register, the _centroid hint can only be specified on either (a) all usages declared for the register, or (b) on none of them.  Also note that the usage 'color' (with any index) has special behavior: even if the centroid hint is not specified for color, it is assumed to be set. "
	D3DSVERR_PS30_DCL_MULTIPLE_USAGES_CENTROID_DISCREPANCY3 = 1073, // 2: "When multple usages are declared for various components of a given input v# register, the _centroid hint can only be specified on either (a) all usages declared for the register, or (b) on none of them.  Also note that the usage 'color' (with any index) has special behavior: even if the centroid hint is not specified for color, it is assumed to be set. "
	D3DSVERR_VS30_RELADDR_OUTREG_ERROR = 1074, // 2: "When relative addressing of output o# registers is used, position0 must be declared in o%d only, psize0 (if present) must be declared in o%d only, and indexing from/into o%d, or o%d (psize0 case only) is undefined. Indexing into any other declared o# is fine. If relative addressing of o# is not used in the shader, these restrictions on register numbers do not apply. "
	D3DSVERR_PS30_SINCOS_DST_REGTYPE_INVALID = 1075, // 2: "Dest for SINCOS must be a temp (r#) register."
	D3DSVERR_VS30_SINCOS_DST_REGTYPE_INVALID = 1076, // 2: "Dest for SINCOS must be a temp (r#) register."
	D3DSVERR_PS30_FLOWCTRL_GRAD_TEMPREG_INVALID = 1077, // 2: "texld/texldb/texldp/dsx/dsy instructions with r# as source cannot be used inside dynamic conditional 'if' blocks, dynamic conditional subroutine calls, or loop/rep with break*. "
	D3DSVERR_PS20_FLOWCTRL_GRAD_TEMPREG_INVALID = 1078, // 2: "texld/texldb/texldp/dsx/dsy instructions with r# as source cannot be used inside dynamic conditional 'if' blocks, dynamic conditional subroutine calls, or rep with break*. "
	D3DSVERR_PS30_SRC_VFACE_INVALID_MODIFIER = 1079, // 2: "Cannot use abs on source parameter(s) on to vFace register."
	D3DSVERR_PS20_FLOWCTRL_STATIC_EXCEEDS_DEVICE2 = 1080 // 2: "ps_2_x extended instruction not supported by the hardware (static flow control not supported)."
} D3DSVERROR_ID;

#define D3DSVERR_CATEGORY_FLAGS_WARNING 0x1 // Compatability warning message (continuable) involving the _sat saturation modifier. Mutually exclusive with D3DSVERR_CATEGORY_FLAGS_ERROR (0x2). Seems to always have the form "...should apply the saturate destination modifier.  This ensures consistent behaviour across different hardware."
#define D3DSVERR_CATEGORY_FLAGS_ERROR 0x2 // Error message (usually causes an abort). Mutually exclusive with D3DSVERR_CATEGORY_FLAGS_WARNING (0x1).
#define D3DSVERR_CATEGORY_FLAGS_OTHER 0x4 // Only ever seen in conjunction with D3DSVERR_CATEGORY_FLAGS_ERROR (never D3DSVERR_CATEGORY_FLAGS_WARNING) messages. It might indicate errors that occur when calling IDirect3DShaderValidator9::End() due to some of the messages appearing to be post-parse checks, but there's also a bunch of messages strewn in there that seem like online checks too.
#define D3DSVERR_CATEGORY_FLAGS_DEVCAPS 0x1000 // This flag is used when a message depends upon DEVCAPS being violated. It is only ever used in combination with D3DSVERR_CATEGORY_FLAGS_ERROR (0x2), but may be used in combination with D3DSVERR_CATEGORY_FLAGS_OTHER (0x4) as well.

typedef void (CALLBACK *IDirect3DShaderValidator9_InstructionCallback)(LPCSTR unknownString /*Seems to always be NULL?*/, 
	UINT unknownUINT /*Seems to always be 0xFFFFFFFF?*/, 
	DWORD messageCategoryFlags /*Some combination of the D3DSVERR_CATEGORY_FLAGS_* flags*/, 
	D3DSVERROR_ID errorID /*Message ID*/, 
	LPCSTR messageString /*Helpful text containing a message description*/, 
	LPVOID lParam /*Same user-specified lParam from IDirect3DShaderValidator9::Begin()*/);

// This is an undocumented D3D9 interface.
// You can create an instance of IDirect3DShaderValidator9 from the d3d9.dll exported function Direct3DShaderValidatorCreate9(void) (see typedef below for "Direct3DShaderValidatorCreate9Type").
struct DECLSPEC_NOVTABLE IDirect3DShaderValidator9 : public IUnknown
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	/*** IDirect3DShaderValidator9 methods ***/

	// IDirect3DShaderValidator9::Begin() must be called to start shader validation. It is illegal to call IDirect3DShaderValidator9::Begin() twice in a row without calling IDirect3DShaderValidator9::End() inbetween.
	STDMETHOD(Begin)(THIS_ IDirect3DShaderValidator9_InstructionCallback lpCallbackFunc /*This callback is called whenever a warning or error message is encountered during shader validation*/,
		LPVOID lParam /*The lParam specified here will be passed to the callback function*/, 
		DWORD unknown /*Not sure what this is used for*/) PURE;

	// This must be called once per shader instruction.
	STDMETHOD(Instruction)(THIS_ CONST char* unknownString /*Not sure what this is used for*/, 
		UINT unknownUInt /*Not sure what this is used for*/, 
		const DWORD* pdwInst /*Pointer to the instruction token in the bytecode stream*/, 
		DWORD dwCount /*The instruction length, in DWORD tokens*/) PURE;

	// IDirect3DShaderValidator9::End() must be called to complete shader validation. It is illegal to call IDirect3DShaderValidator9::End() twice in a row, or to call it before calling IDirect3DShaderValidator9::Begin() first.
	STDMETHOD(End)(THIS) PURE;
};

typedef IDirect3DShaderValidator9* (WINAPI *Direct3DShaderValidatorCreate9Type)(void);
